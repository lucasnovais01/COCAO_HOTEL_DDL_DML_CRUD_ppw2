-- ######################################################################
-- #             SCRIPT DDL: SISTEMA HOTEL COCAO (V15.0)                #
-- ######################################################################
-- Sistema de gerenciamento de hotel com controle de reservas
-- Autor: Lucas Novais de Oliveira
-- Data: Outubro 2025
-- Parte 1/3: Tabelas com ajustes para CODIGO em todas as lookup tables
-- Notas:
-- - Compatível com Oracle Database 21c Express Edition
-- - Sistema projetado para um hotel pequeno e estudantil, evitando supercomplicações.
-- - Não usa tipos BOOLEAN, ARRAY ou OBJECTS para máxima compatibilidade.
-- - Não inclui HASH ou criptografia de senhas (fins didáticos).
-- - RG mantido simples, sem estados ou órgãos emissores.
-- - Índices são removíveis sem quebrar o sistema.
-- - Não há tabela de LOGGING, conforme especificado. No futuro pode ser adicionada se eu quiser, mas só se eu quiser.
-- - Triggers e constraints garantem integridade para um hotel pequeno.
-- ######################################################################

-- ======================================================================
-- 0. LIMPEZA DE OBJETOS ANTERIORES (Ordem Inversa à Criação)
-- ======================================================================
DROP TABLE COCAO_HOSPEDE_SERVICO;
DROP TABLE COCAO_SERVICO;
DROP TABLE COCAO_RESERVA;
DROP TABLE COCAO_STATUS_RESERVA;
DROP TABLE COCAO_QUARTO;
DROP TABLE COCAO_TIPO_QUARTO;
DROP TABLE COCAO_FUNCIONARIO;
DROP TABLE COCAO_FUNCAO;
DROP TABLE COCAO_HOSPEDE;

-- ======================================================================
-- 1. COCAO_HOSPEDE (Superclasse - Generalização)
-- ======================================================================
-- Armazena dados básicos de hóspedes e funcionários
-- TIPO = 0: Hóspede comum
-- TIPO = 1: Funcionário (terá registro em COCAO_FUNCIONARIO)
-- Usa o TRIGGER T11 para impedir exclusão de HOSPEDE reservas ativas
-- EMAIL e TELEFONE são opcionais, mas validados se fornecidos. Pode ter EMAIL e TELEFONE duplicados ou nulos
-- ======================================================================
CREATE TABLE COCAO_HOSPEDE (
    ID_USUARIO INTEGER GENERATED BY DEFAULT AS IDENTITY,
    NOME_HOSPEDE VARCHAR2(100) NOT NULL,
    CPF CHAR(11) NOT NULL,
    RG VARCHAR2(20),
    SEXO CHAR(1) NOT NULL,
    DATA_NASCIMENTO DATE NOT NULL,
    EMAIL VARCHAR2(100),
    TELEFONE VARCHAR2(20),
    TIPO NUMBER(1) DEFAULT 0 NOT NULL,
    ATIVO NUMBER(1) DEFAULT 1,

    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_HOSPEDE PRIMARY KEY (ID_USUARIO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_HOSPEDE_CPF     UNIQUE (CPF),
    -- CHECK
    CONSTRAINT CHK_COCAO_HOSPEDE_SEXO   CHECK (SEXO IN ('M','F','O')),
    CONSTRAINT CHK_COCAO_HOSPEDE_TIPO   CHECK (TIPO IN (0, 1)),
    CONSTRAINT CHK_COCAO_HOSPEDE_ATIVO  CHECK (ATIVO IN (1, 0)),
    -- O check de CPF é o suficiente para fins didáticos, não precisa de uma validação mais complexa
    CONSTRAINT CHK_COCAO_HOSPEDE_CPF    CHECK (REGEXP_LIKE(CPF, '^[0-9]{11}$')),
    CONSTRAINT CHK_COCAO_HOSPEDE_EMAIL  CHECK (EMAIL IS NULL OR REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')),
    CONSTRAINT CHK_COCAO_HOSPEDE_TEL    CHECK (TELEFONE IS NULL OR REGEXP_LIKE(TELEFONE, '^[0-9\s\-\(\)]+$')),
    CONSTRAINT CHK_COCAO_HOSPEDE_RG     CHECK (RG IS NULL OR REGEXP_LIKE(RG, '^[0-9A-Za-z\-]{7,9}$'))
);

-- ======================================================================
-- 2. COCAO_FUNCAO - LOOKUP TABLE
-- ======================================================================
-- Está marcado como 1:1 no DER, mas não usarei UNIQUE no código
-- Armazena os diferentes cargos que funcionários podem ocupar
-- CODIGO: Será por exemplo: 1001, 10002, ou 2001, ou 3001, ... até 9999
-- NIVEL_ACESSO: 1=Básico, 2=Intermediário, 3=Gerencial
-- ======================================================================
CREATE TABLE COCAO_FUNCAO (
    CODIGO_FUNCAO   NUMBER(4), -- Chave primária
    NOME_FUNCAO     VARCHAR2(60) NOT NULL,
    DESCRICAO       VARCHAR2(200),
    NIVEL_ACESSO    NUMBER(1) NOT NULL,
    CREATED_AT      TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT      TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_FUNCAO PRIMARY KEY (CODIGO_FUNCAO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_FUNCAO_NOME UNIQUE (NOME_FUNCAO),
    -- CHECK
    CONSTRAINT CHK_COCAO_FUNCAO_NIVEL CHECK (NIVEL_ACESSO BETWEEN 1 AND 3)
);

-- ======================================================================
-- 3. COCAO_FUNCIONARIO (Subclasse - Especialização de HOSPEDE)
-- ======================================================================
-- Armazena dados específicos de funcionários
-- Herda de COCAO_HOSPEDE onde TIPO = 1
-- As senhas serão sem criptografia neste modelo, pois estudantil
-- o DML de teste crie LOGIN e senha com o respectivo nome da função, exemplo: gerente/gerente, recepcionista/recepcionista, etc...
-- ======================================================================
CREATE TABLE COCAO_FUNCIONARIO (
    ID_USUARIO INTEGER,     -- FK, Referência a COCAO_HOSPEDE
    CODIGO_FUNCAO NUMBER(4),       -- FK, Referência a COCAO_FUNCAO
    NOME_LOGIN VARCHAR2(50) NOT NULL,
    SENHA VARCHAR2(50) NOT NULL,  -- Sem criptografia para fins didáticos
    DATA_CONTRATACAO DATE NOT NULL,
    ATIVO NUMBER(1) DEFAULT 1 NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_FUNCIONARIO PRIMARY KEY (ID_USUARIO),
    -- FOREIGN KEY
    CONSTRAINT FK_COCAO_FUNCIONARIO_HOSPEDE FOREIGN KEY (ID_USUARIO)
        REFERENCES COCAO_HOSPEDE(ID_USUARIO),
    CONSTRAINT FK_COCAO_FUNCIONARIO_CODIGO_FUNCAO FOREIGN KEY (CODIGO_FUNCAO)
        REFERENCES COCAO_FUNCAO(CODIGO_FUNCAO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_FUNCIONARIO_LOGIN UNIQUE (NOME_LOGIN),
    -- CHECK
    CONSTRAINT CHK_COCAO_FUNCIONARIO_ATIVO CHECK (ATIVO IN (1, 0))
);

-- ======================================================================
-- 4. COCAO_TIPO_QUARTO - LOOKUP TABLE (Catálogo de Tipos de Quarto)
-- ======================================================================
-- Exemplo: Solteiro, Casal, Suíte, Luxo
-- ======================================================================
CREATE TABLE COCAO_TIPO_QUARTO (
    CODIGO_TIPO_QUARTO NUMBER(4) NOT NULL,
    NOME_TIPO VARCHAR2(50) NOT NULL, 
    CAPACIDADE_MAXIMA NUMBER(2) DEFAULT 2 NOT NULL,
    VALOR_DIARIA NUMBER(10,2) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_TIPO_QUARTO PRIMARY KEY (CODIGO_TIPO_QUARTO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_TIPO_QUARTO_NOME UNIQUE (NOME_TIPO),
    -- CHECK
    CONSTRAINT CHK_COCAO_TIPO_CAPACIDADE CHECK (CAPACIDADE_MAXIMA > 0),
    CONSTRAINT CHK_COCAO_TIPO_VALOR CHECK (VALOR_DIARIA > 0)
);

-- ======================================================================
-- 5. COCAO_QUARTO (Catálogo de Quartos)
-- ======================================================================
-- Armazena os quartos físicos do hotel, STATUS_QUARTO: LIVRE, OCUPADO, MANUTENCAO
-- Usa o TRIGGER T12 para atualizar STATUS_QUARTO automaticamente
-- ======================================================================
CREATE TABLE COCAO_QUARTO (
    ID_QUARTO INTEGER GENERATED BY DEFAULT AS IDENTITY,
    CODIGO_TIPO_QUARTO NUMBER(4) NOT NULL, -- FK, Referência a COCAO_TIPO_QUARTO
    NUMERO NUMBER NOT NULL,
    STATUS_QUARTO VARCHAR2(20) DEFAULT 'LIVRE',
    ANDAR NUMBER DEFAULT 0 NOT NULL, -- novo campo ANDAR

    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_QUARTO PRIMARY KEY (ID_QUARTO),
    -- FOREIGN KEY
    CONSTRAINT FK_COCAO_QUARTO_CODIGO_TIPO_QUARTO FOREIGN KEY (CODIGO_TIPO_QUARTO)
        REFERENCES COCAO_TIPO_QUARTO(CODIGO_TIPO_QUARTO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_QUARTO_NUMERO UNIQUE (NUMERO),
    -- CHECK
    CONSTRAINT CHK_COCAO_QUARTO_STATUS CHECK (STATUS_QUARTO IN ('LIVRE','OCUPADO','MANUTENCAO')),
    CONSTRAINT CHK_COCAO_QUARTO_NUMERO CHECK (NUMERO >= 1),
    CONSTRAINT CHK_COCAO_QUARTO_ANDAR CHECK (ANDAR BETWEEN 0 AND 5) -- Andar 0 para térreo, por exemplo
);

-- ======================================================================
-- 6. COCAO_STATUS_RESERVA - LOOKUP TABLE (Tabela de Domínio)
-- ======================================================================
-- CODIGO: 1, 2, 3, 4, 5, e respectivamente
-- DESCRICAO: ABERTA, ATIVA, A_PAGAR, FINALIZADA, CANCELADA
-- ======================================================================
CREATE TABLE COCAO_STATUS_RESERVA (
    CODIGO_STATUS NUMBER(1) NOT NULL,
    DESCRICAO VARCHAR2(20) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_STATUS_RESERVA PRIMARY KEY (CODIGO_STATUS),
    -- UNIQUE
    CONSTRAINT UK_COCAO_STATUS_DESCRICAO UNIQUE (DESCRICAO)
);

-- ======================================================================
-- 7. COCAO_RESERVA (Transacional - Núcleo do Sistema)
-- ======================================================================
-- Gerencia as reservas
-- VALOR_TOTAL é calculado automaticamente via triggers (T16 e T17)
-- Usa o TRIGGER T13 para atualizar STATUS_QUARTO em COCAO_QUARTO com base em reservas ATIVAS
-- Usa o TRIGGER T14 para controlar transições de status de reservas
-- Usa o TRIGGER T15 para validar datas de check-in e check-out

-- ######################################################################
-- # Comentários para COCAO_RESERVA: Orientações para o Front-end/API    #
-- ######################################################################
-- NOTA PARA DESENVOLVEDORES DO FRONT-END/API:
-- A tabela COCAO_RESERVA opera no paradigma de diárias de calendário, onde as reservas são baseadas em dias 
-- completos (00:00:00 a 23:59:59), e a cobrança é feita por noites (TRUNC(DATA_CHECK_OUT) - TRUNC(DATA_CHECK_IN)).
-- Requisitos críticos para inserções e atualizações:
-- 1. Triggers T14 e T15 já truncam DATA_CHECK_IN e DATA_CHECK_OUT automaticamente, então o front-end não precisa truncar as datas.
-- 2. DATA_CHECK_OUT deve ser estritamente posterior a DATA_CHECK_IN (mínimo 1 diária). Exemplo:
--    - Válido: DATA_CHECK_IN = 22/10/2025, DATA_CHECK_OUT = 23/10/2025
--    - Inválido: DATA_CHECK_IN = 22/10/2025, DATA_CHECK_OUT = 22/10/2025
-- 3. O cálculo de diárias é feito como TRUNC(DATA_CHECK_OUT) - TRUNC(DATA_CHECK_IN), representando o número de noites. Exemplo:
--    - Check-in: 22/10/2025, Check-out: 23/10/2025 = 1 diária
--    - Check-in: 22/10/2025, Check-out: 24/10/2025 = 2 diárias
-- 4. Serviços solicitados (COCAO_HOSPEDE_SERVICO) seram contabilizados, a partir da data do período de reserva, mesmo que antes do check-in,
--    por exemplo, um pessoa faz uma reserva pra semana que vem, porém já pede um serviço de estacionamento ou café da manhã, mas não foi feito o check-in ainda.
--    Exemplo: Para uma reserva de 22/11/2025 a 23/11/2025, só que uma semana antes, a pessoa já pediu um serviço de café da manhã para o dia 22/11/2025.
--    Esse valor do serviço deve ser contabilizado no VALOR_TOTAL da reserva. Contanto que o serviço foi consumado é claro, tudo é avaliado no data do check-out.
-- 5. Para evitar bloqueios prolongados no banco (T15), o front-end deve validar conflitos de reserva antes de enviar ao banco:
--    - Consultar COCAO_RESERVA para verificar se o quarto (ID_QUARTO) tem reservas com status ABERTA ou ATIVA
--      no período solicitado (DATA_CHECK_IN a DATA_CHECK_OUT).
--    - Exemplo de consulta SQL para validação:
--      SELECT COUNT(*) FROM COCAO_RESERVA r
--      WHERE r.ID_QUARTO = :id_quarto
--        AND r.CODIGO IN (SELECT CODIGO FROM COCAO_STATUS_RESERVA WHERE DESCRICAO IN ('ABERTA', 'ATIVA'))
--        AND TRUNC(r.DATA_CHECK_OUT) > TRUNC(:data_check_in)
--        AND TRUNC(r.DATA_CHECK_IN) < TRUNC(:data_check_out);
--    - Se COUNT > 0, exibir erro ao usuário antes de enviar ao banco.
-- ======================================================================
CREATE TABLE COCAO_RESERVA (
    ID_RESERVA INTEGER GENERATED BY DEFAULT AS IDENTITY,
    CODIGO_STATUS NUMBER(1) DEFAULT 1 NOT NULL,     -- FK, Referência a COCAO_STATUS_RESERVA
    ID_USUARIO INTEGER NOT NULL,                    -- FK, Referência a COCAO_HOSPEDE
    ID_QUARTO INTEGER NOT NULL,                     -- FK, Referência a COCAO_QUARTO
    DATA_CHECK_IN DATE NOT NULL,
    DATA_CHECK_OUT DATE NOT NULL,
    NUMERO_HOSPEDES NUMBER(2) DEFAULT 1 NOT NULL,
    VALOR_TOTAL NUMBER(10,2),
    NUMERO_DIARIAS NUMBER(4) DEFAULT 0 NOT NULL,

    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_RESERVA PRIMARY KEY (ID_RESERVA),
    -- FOREIGN KEY
    CONSTRAINT FK_COCAO_RESERVA_HOSPEDE FOREIGN KEY (ID_USUARIO)
        REFERENCES COCAO_HOSPEDE(ID_USUARIO),
    CONSTRAINT FK_COCAO_RESERVA_QUARTO FOREIGN KEY (ID_QUARTO)
        REFERENCES COCAO_QUARTO(ID_QUARTO),
    CONSTRAINT FK_COCAO_RESERVA_CODIGO_STATUS FOREIGN KEY (CODIGO_STATUS)
        REFERENCES COCAO_STATUS_RESERVA(CODIGO_STATUS),
    -- CHECK
    CONSTRAINT CHK_COCAO_RESERVA_HOSPEDE CHECK (NUMERO_HOSPEDES <= 10), -- Maximo até 10 hóspedes, preservando o sistema
    CONSTRAINT CHK_COCAO_RESERVA_VALOR CHECK (VALOR_TOTAL >= 0),
    CONSTRAINT CHK_COCAO_RESERVA_DATA1 CHECK (DATA_CHECK_OUT > DATA_CHECK_IN),
    CONSTRAINT CHK_COCAO_RESERVA_DATA2 CHECK (DATA_CHECK_IN >= TRUNC(SYSDATE)),
    CONSTRAINT CHK_COCAO_RESERVA_DIARIAS CHECK (NUMERO_DIARIAS >= 0) -- Restrição simplificada, cálculo movido para T15
    -- Descartado, pois vai ser feito pelo TRIGGER T15
    -- CONSTRAINT CHK_COCAO_RESERVA_DIARIAS CHECK (NUMERO_DIARIAS = TRUNC(DATA_CHECK_OUT) - TRUNC(DATA_CHECK_IN));
);


-- ======================================================================
-- 8. COCAO_SERVICO - LOOKUP TABLE (Catálogo de Serviços Adicionais)
-- ======================================================================
-- Serviços oferecidos aos hóspedes, exemplo: Café da manhã, Lavanderia, Room Service
-- Código simples, como 0101, 0020, .. 0100, ... Pois tenho uma tabela onde os primeiros digitos indicam categoria etc..
-- Usa o TRIGGER T16 para atualizar VALOR_TOTAL em COCAO_RESERVA
-- ======================================================================
CREATE TABLE COCAO_SERVICO (
    CODIGO_SERVICO NUMBER(4) NOT NULL,
    NOME_SERVICO VARCHAR2(100) NOT NULL,
    PRECO NUMBER(10,2) NOT NULL,
    ATIVO NUMBER(1) DEFAULT 1,
    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_SERVICO PRIMARY KEY (CODIGO_SERVICO),
    -- UNIQUE
    CONSTRAINT UK_COCAO_SERVICO_NOME UNIQUE (NOME_SERVICO),
    -- CHECK
    CONSTRAINT CHK_COCAO_SERVICO_PRECO CHECK (PRECO >= 0),
    CONSTRAINT CHK_COCAO_SERVICO_ATIVO CHECK (ATIVO IN (1, 0))
);

-- ======================================================================
-- 9. COCAO_HOSPEDE_SERVICO (Transacional - Solicitação de Serviços)
-- ======================================================================
-- Registra serviços solicitados por hóspedes durante a estadia
-- Usa o TRIGGER T17 para atualizar VALOR_TOTAL em COCAO_RESERVA
-- Usa o TRIGGER T18 para garantir unicidade por hóspede, serviço e data
-- Adicionado a FK ID_RESERVA para vincular ao período de reserva
-- ======================================================================
CREATE TABLE COCAO_HOSPEDE_SERVICO (
    ID_SOLICITACAO      INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ID_USUARIO          INTEGER NOT NULL,       -- FK, Referência a COCAO_HOSPEDE
    CODIGO_SERVICO      NUMBER(4) NOT NULL,     -- FK, Referência a COCAO_SERVICO
    ID_RESERVA          INTEGER NOT NULL,       -- FK, Referência a COCAO_RESERVA (NOVO)
    DATA_SOLICITACAO    DATE DEFAULT SYSTIMESTAMP NOT NULL,
    QUANTIDADE          NUMBER DEFAULT 1,

    CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    UPDATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    -- PRIMARY KEY
    CONSTRAINT PK_COCAO_HS_SOLICITACAO PRIMARY KEY (ID_SOLICITACAO),
    -- FOREIGN KEY
    CONSTRAINT FK_COCAO_HS_HOSPEDE FOREIGN KEY (ID_USUARIO)
        REFERENCES COCAO_HOSPEDE(ID_USUARIO),
    CONSTRAINT FK_COCAO_HS_CODIGO_SERVICO FOREIGN KEY (CODIGO_SERVICO)
        REFERENCES COCAO_SERVICO(CODIGO_SERVICO),
    CONSTRAINT FK_COCAO_HS_ID_RESERVA FOREIGN KEY (ID_RESERVA)
        REFERENCES COCAO_RESERVA(ID_RESERVA),
    -- CHECK
    CONSTRAINT CHK_COCAO_HS_QUANTIDADE CHECK (QUANTIDADE <= 100) -- Limite de 100 unidades para preservar o sistema
);

-- ======================================================================
-- 10. INDICES ADICIONAIS (se necessário) e VIEWS e STORED FUNCTION
-- Regra de ouro, NÃO TORNAR O CÓDIGO DEPENDENDETE DE ÍNDICES, VIEW OU STORED FUNCTIONS, elas precisam ser opcionais e podem ser deletadas a qualquer momento.
-- ======================================================================
-- - Nota: Indices 01 e 05, foram comentados, pois não são mais necessários, ficaram comentado para fins didáticos.
-- ======================================================================
-- este indice se torna util para o trigger T11, mas agora não sei se é mais necessário
-- CREATE INDEX COCAO_HOTEL_01_IDX_HOSPEDE_TIPO ON COCAO_HOSPEDE (TIPO);
-- este indice se torna util para o trigger T13, mas agora não sei se é mais necessário
-- CREATE INDEX COCAO_HOTEL_05_IDX_QUARTO_STATUS ON COCAO_QUARTO (STATUS_QUARTO);

CREATE INDEX COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA ON COCAO_RESERVA (ID_QUARTO, CODIGO_STATUS, DATA_CHECK_IN, DATA_CHECK_OUT);

CREATE INDEX COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO ON COCAO_HOSPEDE_SERVICO (ID_USUARIO, CODIGO_SERVICO, DATA_SOLICITACAO);


-- VIEW ANTIGA COMENTADA (VERSÃO 14.4) --
/*
CREATE OR REPLACE VIEW COCAO_HOTEL_VIEW_01_STATUS_QUARTO AS
SELECT 
    q.ID_QUARTO,
    CASE 
        WHEN q.STATUS_QUARTO = 'MANUTENCAO' THEN 'MANUTENCAO'
        WHEN EXISTS (
            SELECT 1
            FROM COCAO_RESERVA r
            JOIN COCAO_STATUS_RESERVA sr ON r.CODIGO_STATUS = sr.CODIGO_STATUS
            WHERE r.ID_QUARTO = q.ID_QUARTO
              AND sr.DESCRICAO IN ('ABERTA', 'ATIVA')
              AND TRUNC(r.DATA_CHECK_OUT) > NVL(TRUNC(:data_inicio), TRUNC(SYSDATE))
              AND TRUNC(r.DATA_CHECK_IN) <= NVL(TRUNC(:data_fim), TRUNC(SYSDATE))
        ) THEN 'OCUPADO'
        ELSE 'LIVRE'
    END AS STATUS_QUARTO,
    NVL(TRUNC(:data_inicio), TRUNC(SYSDATE)) AS DATA_INICIO,
    NVL(TRUNC(:data_fim), TRUNC(SYSDATE)) AS DATA_FIM
FROM COCAO_QUARTO q;
*/

-- ======================================================================
-- COCAO_HOTEL_VIEW_01_STATUS_QUARTO - View para Relatórios de Disponibilidade
-- ======================================================================
-- TREINO COM USO DE VIEW
-- Exibe o status dos quartos (LIVRE, OCUPADO, MANUTENCAO) com base em reservas
-- [ALTERAÇÃO v15.0]: Removidas bind variables (:data_inicio, :data_fim) para compatibilidade
--                    Usa SYSDATE como padrão, permitindo filtros via WHERE no front-end
-- Uso recomendado: 
--   SELECT * FROM COCAO_HOTEL_VIEW_01_STATUS_QUARTO 
--   WHERE DATA_INICIO = TO_DATE('01/01/2026', 'DD/MM/YYYY') 
--     AND DATA_FIM = TO_DATE('03/01/2026', 'DD/MM/YYYY');
--   Se não fornecer DATA_INICIO/DATA_FIM, exibe status para o dia atual (SYSDATE)
-- ======================================================================
CREATE OR REPLACE VIEW COCAO_HOTEL_VIEW_01_STATUS_QUARTO AS
SELECT 
    q.ID_QUARTO,
    CASE 
        WHEN q.STATUS_QUARTO = 'MANUTENCAO' THEN 'MANUTENCAO'
        WHEN EXISTS (
            SELECT 1
            FROM COCAO_RESERVA r
            JOIN COCAO_STATUS_RESERVA sr ON r.CODIGO_STATUS = sr.CODIGO_STATUS
            WHERE r.ID_QUARTO = q.ID_QUARTO
              AND sr.DESCRICAO IN ('ABERTA', 'ATIVA')
              AND TRUNC(r.DATA_CHECK_OUT) > TRUNC(SYSDATE)
              AND TRUNC(r.DATA_CHECK_IN) <= TRUNC(SYSDATE)
        ) THEN 'OCUPADO'
        ELSE 'LIVRE'
    END AS STATUS_QUARTO,
    TRUNC(SYSDATE) AS DATA_INICIO,
    TRUNC(SYSDATE) AS DATA_FIM
FROM COCAO_QUARTO q;

-- ======================================================================
-- COCAO_HOTEL_SF_STATUS_QUARTO - Função PL/SQL para Relatórios de Disponibilidade
-- ======================================================================
-- Exibe o status dos quartos (LIVRE, OCUPADO, MANUTENCAO) com base em reservas
-- Aceita parâmetros de data para consultas de disponibilidade em períodos específicos
-- Mantém prioridade de MANUTENCAO sobre reservas
-- Simplificado para relatórios dinâmicos em dashboards
-- Uso recomendado: 
--   SELECT * FROM TABLE(COCAO_HOTEL_SF_STATUS_QUARTO(
--       TO_DATE('01/01/2026', 'DD/MM/YYYY'),
--       TO_DATE('03/01/2026', 'DD/MM/YYYY')
--   ));
--   Se p_data_inicio/p_data_fim forem NULL, usa SYSDATE para status atual
-- ======================================================================
CREATE OR REPLACE FUNCTION COCAO_HOTEL_SF_STATUS_QUARTO (
    p_data_inicio IN DATE,
    p_data_fim IN DATE
) RETURN SYS_REFCURSOR AS
    l_cursor SYS_REFCURSOR;
BEGIN
    -- Validar se p_data_inicio <= p_data_fim
    IF p_data_inicio IS NOT NULL AND p_data_fim IS NOT NULL AND p_data_inicio > p_data_fim THEN
        RAISE_APPLICATION_ERROR(-20099,
            '[-20099] COCAO_HOTEL_SF_STATUS_QUARTO: Período inválido. ' ||
            'Data de início (' || TO_CHAR(p_data_inicio, 'DD/MM/YYYY') || ') não pode ser posterior à data de fim (' ||
            TO_CHAR(p_data_fim, 'DD/MM/YYYY') || ').');
    END IF;

    -- Uso em SQL:
    --   SELECT * FROM TABLE(COCAO_HOTEL_SF_STATUS_QUARTO(
    --       TO_DATE('01/01/2026', 'DD/MM/YYYY'),
    --       TO_DATE('03/01/2026', 'DD/MM/YYYY')
    --   ));
    -- Uso em Java (exemplo):
    --   CallableStatement stmt = conn.prepareCall("{ ? = call COCAO_HOTEL_SF_STATUS_QUARTO(?, ?) }");
    --   stmt.registerOutParameter(1, OracleTypes.CURSOR);
    --   stmt.setDate(2, java.sql.Date.valueOf("2026-01-01"));
    --   stmt.setDate(3, java.sql.Date.valueOf("2026-01-03"));
    --   stmt.execute();
    --   ResultSet rs = (ResultSet) stmt.getObject(1);
    --   while (rs.next()) {
    --       System.out.println(rs.getInt("ID_QUARTO") + ": " + rs.getString("STATUS_QUARTO"));
    --   }
    -- Uso em Python (exemplo com cx_Oracle):
    --   cursor = connection.cursor()
    --   cursor.callfunc('COCAO_HOTEL_SF_STATUS_QUARTO', cx_Oracle.CURSOR, [date(2026, 1, 1), date(2026, 1, 3)])
    --   for row in cursor:
    --       print(row)
    -- Nota: Se p_data_inicio ou p_data_fim forem NULL, usa SYSDATE como padrão
    OPEN l_cursor FOR
        SELECT 
            q.ID_QUARTO,
            CASE 
                WHEN q.STATUS_QUARTO = 'MANUTENCAO' THEN 'MANUTENCAO'
                WHEN EXISTS (
                    SELECT 1
                    FROM COCAO_RESERVA r
                    JOIN COCAO_STATUS_RESERVA sr ON r.CODIGO_STATUS = sr.CODIGO_STATUS
                    WHERE r.ID_QUARTO = q.ID_QUARTO
                      AND sr.DESCRICAO IN ('ABERTA', 'ATIVA')
                      AND TRUNC(r.DATA_CHECK_OUT) > NVL(TRUNC(p_data_inicio), TRUNC(SYSDATE))
                      AND TRUNC(r.DATA_CHECK_IN) <= NVL(TRUNC(p_data_fim), TRUNC(SYSDATE))
                ) THEN 'OCUPADO'
                ELSE 'LIVRE'
            END AS STATUS_QUARTO,
            NVL(TRUNC(p_data_inicio), TRUNC(SYSDATE)) AS DATA_INICIO,
            NVL(TRUNC(p_data_fim), TRUNC(SYSDATE)) AS DATA_FIM
        FROM COCAO_QUARTO q;
    RETURN l_cursor;
END;
/


-- ######################################################################
-- #           TRIGGERS DE AUDITORIA - PARTE 2/3 - (T01 a T09)          #
-- ######################################################################
-- - Função: Gerenciam CREATED_AT e UPDATED_AT com SYSTIMESTAMP
-- - Garante que CREATED_AT e UPDATED_AT sejam atualizados corretamente
-- - Acionados BEFORE INSERT OR UPDATE, mantendo CREATED_AT inalterado em atualizações
-- - Inclui proteção contra conflitos de herança (TIPO) em COCAO_HOSPEDE e COCAO_FUNCIONARIO
-- - T10 reservado para futuro trigger de logging

-- ======================================================================
-- T01: COCAO_HOSPEDE - Auditoria com Proteção para Herança
-- ======================================================================
-- Protege contra conflitos com COCAO_FUNCIONARIO (herança com TIPO = 1)
-- Usa SYSTIMESTAMP para consistência com colunas TIMESTAMP
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_01_TRG_AUDITORIA_HOSPEDE
BEFORE INSERT OR UPDATE ON COCAO_HOSPEDE
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Atualiza UPDATED_AT, exceto para mudança de TIPO
    IF UPDATING AND NOT UPDATING('TIPO') THEN
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T02: COCAO_FUNCAO - Auditoria de Criação e Atualização
-- ======================================================================

CREATE OR REPLACE TRIGGER COCAO_HOTEL_02_TRG_AUDITORIA_FUNCAO
BEFORE INSERT OR UPDATE ON COCAO_FUNCAO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T03: COCAO_FUNCIONARIO - Auditoria com Proteção para Herança
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_03_TRG_AUDITORIA_FUNCIONARIO
BEFORE INSERT OR UPDATE ON COCAO_FUNCIONARIO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Atualiza UPDATED_AT, exceto para mudança de TIPO
    IF UPDATING AND NOT UPDATING('TIPO') THEN
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/
-- ======================================================================
-- T04: COCAO_TIPO_QUARTO - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_04_TRG_AUDITORIA_TIPO_QUARTO
BEFORE INSERT OR UPDATE ON COCAO_TIPO_QUARTO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T05: COCAO_QUARTO - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_05_TRG_AUDITORIA_QUARTO
BEFORE INSERT OR UPDATE ON COCAO_QUARTO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T06: COCAO_STATUS_RESERVA - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_06_TRG_AUDITORIA_STATUS_RESERVA
BEFORE INSERT OR UPDATE ON COCAO_STATUS_RESERVA
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T07: COCAO_RESERVA - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_07_TRG_AUDITORIA_RESERVA
BEFORE INSERT OR UPDATE ON COCAO_RESERVA
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T08: COCAO_SERVICO - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_08_TRG_AUDITORIA_SERVICO
BEFORE INSERT OR UPDATE ON COCAO_SERVICO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ======================================================================
-- T09: COCAO_HOSPEDE_SERVICO - Auditoria de Criação e Atualização
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_09_TRG_AUDITORIA_HOSPEDE_SERVICO
BEFORE INSERT OR UPDATE ON COCAO_HOSPEDE_SERVICO
FOR EACH ROW
BEGIN
    -- INSERT: Define CREATED_AT
    IF INSERTING THEN
        :NEW.CREATED_AT := SYSTIMESTAMP;
    END IF;
    
    -- UPDATE: Mantém CREATED_AT e atualiza UPDATED_AT
    IF UPDATING THEN
        :NEW.CREATED_AT := :OLD.CREATED_AT;
        :NEW.UPDATED_AT := SYSTIMESTAMP;
    END IF;
END;
/

-- ######################################################################
-- #               TRIGGERS DE INTEGRIDADE - PARTE 3/3                  #
-- ######################################################################
-- - Compatível com Oracle Database 21c Express Edition
-- - Usa TRUNC(SYSDATE) diretamente para validações temporais, 
-- - garantindo paradigma de diárias de calendário (sem precisão de hora)
-- Novo: Ajustes realizados para corrigir tipos de dados (CODIGO), eliminar hardcoding,
--       otimizar performance com BULK COLLECT/FORALL, melhorar concorrência e reduzir
--       dependência do front-end.
-- Novo: Mantidos os índices existentes (COCAO_HOTEL_01_IDX_HOSPEDE_TIPO,
--       COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA, COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO)
--       conforme criado no script original.
-- Novo: CODIGO em COCAO_RESERVA alterado para NUMBER(1) e em COCAO_HOSPEDE_SERVICO
--       para NUMBER(4) para alinhar com COCAO_STATUS_RESERVA e COCAO_SERVICO.
-- Novo: Triggers otimizados para hotel pequeno, evitando supercomplicação.

-- ======================================================================
-- T11: COCAO_HOSPEDE - Impede Exclusão com Reservas Ativas
-- ======================================================================
-- Impede exclusão de hóspedes com reservas ABERTA (1), ATIVA (2) ou A_PAGAR (3)
-- Impede exclusão de funcionários (TIPO = 1) sem antes remover de COCAO_FUNCIONARIO
-- Usa valores numéricos diretos (1=ABERTA, 2=ATIVA, 3=A_PAGAR) para simplicidade
-- Usa índice COCAO_HOTEL_01_IDX_HOSPEDE_TIPO para melhorar performance
-- Novo: Remove FOR UPDATE, pois apenas consulta COCAO_RESERVA
-- Novo: Mensagem de erro ajustada para orientar exclusão em COCAO_FUNCIONARIO
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_11_TRG_HOSPEDE_DELETE
BEFORE DELETE ON COCAO_HOSPEDE
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    IF :OLD.TIPO = 1 THEN
        RAISE_APPLICATION_ERROR(-20020,
            '[-20020] COCAO_HOSPEDE/T11: Exclusão de funcionário bloqueada. ' ||
            'ID ' || :OLD.ID_USUARIO || ' é um funcionário (TIPO = 1). ' ||
            'Exclua o registro correspondente em COCAO_FUNCIONARIO antes de excluir de COCAO_HOSPEDE.');
    END IF;
    
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA
    WHERE ID_USUARIO = :OLD.ID_USUARIO
      AND CODIGO_STATUS IN (1, 2, 3) -- ABERTA, ATIVA, A_PAGAR
      AND TRUNC(SYSDATE) < TRUNC(DATA_CHECK_OUT);
    
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20021,
            '[-20021] COCAO_HOSPEDE/T11: Exclusão de hóspede bloqueada. ' ||
            'Hóspede ID ' || :OLD.ID_USUARIO || ' possui ' || v_count || ' reserva(s) ativa(s), aberta(s) ou a pagar. ' ||
            'Cancele ou finalize as reservas antes de excluir.');
    END IF;
END;
/

-- ======================================================================
-- T12: COCAO_QUARTO - Validação de Status em MANUTENCAO
-- ======================================================================
-- Objetivo: Impede que quartos sejam marcados como MANUTENCAO se houver reservas
--           ABERTA (1) ou ATIVA (2) com check-out futuro. Exibe uma mensagem
--           detalhada com as reservas afetadas, orientando o gerente a realocá-las.
-- Justificativa: Resolve o problema de "Manutenção Futura" permitindo que o gerente
--               realoque reservas manualmente para um quarto disponível (quarto de
--               emergência) usando COCAO_HOTEL_VIEW_01_STATUS_QUARTO.
-- Funcionamento:
-- - Verifica reservas com CODIGO_STATUS IN (1, 2) e DATA_CHECK_OUT > SYSDATE.
-- - Se houver conflitos, levanta erro com detalhes das reservas afetadas.
-- - Usa FOR UPDATE WAIT 5 para evitar deadlocks prolongados.
-- - Índice COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA melhora performance.
-- Instruções para o gerente:
-- 1. Ao receber erro [-20030], note os ID_RESERVA, DATA_CHECK_IN e DATA_CHECK_OUT
--    listados na mensagem.
-- 2. Consulte COCAO_HOTEL_VIEW_01_STATUS_QUARTO para encontrar quartos disponíveis:
--    SELECT ID_QUARTO, STATUS_QUARTO
--    FROM COCAO_HOTEL_VIEW_01_STATUS_QUARTO
--    WHERE STATUS_QUARTO = 'LIVRE'
--      AND DATA_INICIO = :data_check_in
--      AND DATA_FIM = :data_check_out;
-- 3. Atualize COCAO_RESERVA com o novo ID_QUARTO para cada reserva afetada:
--    UPDATE COCAO_RESERVA
--    SET ID_QUARTO = :novo_id_quarto
--    WHERE ID_RESERVA = :id_reserva;
-- 4. Após realocar todas as reservas, tente novamente marcar o quarto como MANUTENCAO.
-- 5. Após a manutenção (ex.: troca de lâmpada), atualize STATUS_QUARTO para LIVRE:
--    UPDATE COCAO_QUARTO
--    SET STATUS_QUARTO = 'LIVRE'
--    WHERE ID_QUARTO = :id_quarto;
-- Instruções para o front-end:
-- - Capture o erro [-20030] e exiba a lista de reservas afetadas ao gerente.
-- - Forneça uma interface para consultar quartos disponíveis (usando a view) e
--   atualizar ID_QUARTO nas reservas afetadas.
-- - Exemplo de consulta para sugerir quartos disponíveis:
--   SELECT q.ID_QUARTO, q.NUMERO, t.NOME_TIPO, t.CAPACIDADE_MAXIMA
--   FROM COCAO_QUARTO q
--   JOIN COCAO_TIPO_QUARTO t ON q.CODIGO_TIPO_QUARTO = t.CODIGO_TIPO_QUARTO
--   WHERE q.ID_QUARTO IN (
--       SELECT ID_QUARTO
--       FROM COCAO_HOTEL_VIEW_01_STATUS_QUARTO
--       WHERE STATUS_QUARTO = 'LIVRE'
--         AND DATA_INICIO = :data_check_in
--         AND DATA_FIM = :data_check_out
--   );
-- Novo:
-- - Adicionada mensagem de erro detalhada com lista de reservas afetadas.
-- - Incluídas instruções para o gerente realocar reservas manualmente.
-- - Mantida simplicidade, sem tabela adicional para agendamento de manutenção.
-- - Suporta cenário onde o quarto volta a LIVRE antes do check-in (nenhuma ação
--   necessária se a manutenção for concluída).
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_12_TRG_STATUS_QUARTO
BEFORE INSERT OR UPDATE OF STATUS_QUARTO ON COCAO_QUARTO
FOR EACH ROW
DECLARE
    v_count NUMBER;
    v_reservas VARCHAR2(4000) := '';
    CURSOR c_reservas IS
        SELECT ID_RESERVA, DATA_CHECK_IN, DATA_CHECK_OUT
        FROM COCAO_RESERVA
        WHERE ID_QUARTO = :NEW.ID_QUARTO
          AND CODIGO_STATUS IN (1, 2) -- ABERTA, ATIVA
          AND TRUNC(DATA_CHECK_OUT) > TRUNC(SYSDATE)
        FOR UPDATE WAIT 5;
BEGIN
    IF :NEW.STATUS_QUARTO = 'MANUTENCAO' THEN
        -- Contar reservas conflitantes
        SELECT COUNT(*)
        INTO v_count
        FROM COCAO_RESERVA
        WHERE ID_QUARTO = :NEW.ID_QUARTO
          AND CODIGO_STATUS IN (1, 2) -- ABERTA, ATIVA
          AND TRUNC(DATA_CHECK_OUT) > TRUNC(SYSDATE);
        
        IF v_count > 0 THEN
            -- Construir lista de reservas afetadas
            FOR r IN c_reservas LOOP
                v_reservas := v_reservas || 
                    'Reserva ID: ' || r.ID_RESERVA || 
                    ', Check-in: ' || TO_CHAR(r.DATA_CHECK_IN, 'DD/MM/YYYY') || 
                    ', Check-out: ' || TO_CHAR(r.DATA_CHECK_OUT, 'DD/MM/YYYY') || '; ';
            END LOOP;
            
            RAISE_APPLICATION_ERROR(-20030,
                '[-20030] COCAO_QUARTO/T12: Não é possível alterar quarto para MANUTENCAO. ' ||
                'Quarto ID ' || :NEW.ID_QUARTO || ' possui ' || v_count || 
                ' reserva(s) ativa(s) ou aberta(s) com check-out após ' ||
                TO_CHAR(TRUNC(SYSDATE), 'DD/MM/YYYY') || '. ' ||
                'Reservas afetadas: ' || v_reservas || 
                'Realoque as reservas para outro quarto usando COCAO_HOTEL_VIEW_01_STATUS_QUARTO ' ||
                'para encontrar quartos disponíveis no período e atualize ID_QUARTO em COCAO_RESERVA.');
        END IF;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_QUARTO/T12: Tempo de espera excedido para bloqueio da reserva. ' ||
                'Quarto ID ' || :NEW.ID_QUARTO || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE;
        END IF;
END;
/

-- ======================================================================
-- T13: COCAO_RESERVA - Atualização de STATUS_QUARTO
-- ======================================================================
-- Atualiza STATUS_QUARTO em COCAO_QUARTO com base em reservas ATIVAS (2)
-- Usa CODIGO_STATUS em vez de ID_STATUS_RESERVA
-- Trata DATA_CHECK_OUT como exclusivo
-- Como funciona: O quarto deve permanecer aberto, ele só muda pra ocupado a partir do primeiro dia da reserva, entenda, 
-- imagine que alguém faz uma reserva de 2 dias, pra daqui 300 dias, não faz sentido este quarto ficar marcado como ocupado até o dia do check-out.
-- Novo: Simplificado de compound trigger para trigger simples, suficiente para hotel pequeno.
-- Novo: Removido COCAO_HOTEL_CONSTANTS, usado valores numéricos diretos.
-- Novo: Índice COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA já criado, melhora performance.
-- Novo: Adicionado FOR UPDATE WAIT 5 para limitar tempo de espera em bloqueios.
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_13_TRG_RESERVA_STATUS_QUARTO
AFTER INSERT OR UPDATE OF CODIGO_STATUS, DATA_CHECK_IN, DATA_CHECK_OUT, ID_QUARTO ON COCAO_RESERVA
FOR EACH ROW
DECLARE
    v_count NUMBER;
    v_status_quarto COCAO_QUARTO.STATUS_QUARTO%TYPE;
BEGIN
    -- Verificar o status atual do quarto
    SELECT STATUS_QUARTO
    INTO v_status_quarto
    FROM COCAO_QUARTO
    WHERE ID_QUARTO = :NEW.ID_QUARTO;
    
    -- Se o quarto está em MANUTENCAO, não atualizar o status
    IF v_status_quarto = 'MANUTENCAO' THEN
        RETURN;
    END IF;
    
    -- Contar reservas ativas
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA r
    WHERE r.ID_QUARTO = :NEW.ID_QUARTO
      AND r.CODIGO_STATUS = 2 -- ATIVA
      AND TRUNC(r.DATA_CHECK_OUT) > TRUNC(SYSDATE);
    
    -- Atualizar STATUS_QUARTO apenas se não estiver em MANUTENCAO
    UPDATE COCAO_QUARTO q
    SET q.STATUS_QUARTO = CASE 
        WHEN v_count > 0 THEN 'OCUPADO'
        ELSE 'LIVRE'
    END
    WHERE q.ID_QUARTO = :NEW.ID_QUARTO
    FOR UPDATE WAIT 5;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20010,
            '[-20010] COCAO_RESERVA/T13: Falha na atualização de status do quarto. ' ||
            'Quarto ID ' || :NEW.ID_QUARTO || ' não encontrado em COCAO_QUARTO. ' ||
            'Verifique o ID do quarto na reserva.');
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_RESERVA/T13: Tempo de espera excedido para bloqueio do quarto. ' ||
                'Quarto ID ' || :NEW.ID_QUARTO || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_RESERVA/T13: Erro inesperado ao atualizar STATUS_QUARTO. ' ||
                'Erro: ' || SQLERRM);
        END IF;
END;
/

-- ======================================================================
-- T14: COCAO_RESERVA - Controle de Transição de Status
-- ======================================================================
-- Controla o fluxo de status das reservas, garantindo transições lógicas
-- DIAGRAMA DE ESTADOS:
-- ABERTA (1) → ATIVA (2), A_PAGAR (3), CANCELADA (5)
-- ATIVA (2) → A_PAGAR (3), FINALIZADA (4)
-- A_PAGAR (3) → FINALIZADA (4), CANCELADA (5)
-- FINALIZADA (4) → (TERMINAL)
-- CANCELADA (5) → (TERMINAL)
-- NOTA: Truncamento de DATA_CHECK_IN e DATA_CHECK_OUT é feito por T15
-- Novo: Removido truncamento redundante de DATA_CHECK_IN e DATA_CHECK_OUT
-- Novo: Ajustado para CODIGO_STATUS NUMBER(1)
-- Novo: Comentário atualizado para esclarecer dependência de T15
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_14_TRG_RESERVA_STATUS_TRANSICAO
BEFORE UPDATE OF CODIGO_STATUS ON COCAO_RESERVA
FOR EACH ROW
BEGIN
    IF :OLD.CODIGO_STATUS = :NEW.CODIGO_STATUS THEN
        RETURN;
    END IF;
    
    CASE :OLD.CODIGO_STATUS
        WHEN 1 THEN -- ABERTA
            IF :NEW.CODIGO_STATUS NOT IN (2, 3, 5) THEN -- ATIVA, A_PAGAR, CANCELADA
                RAISE_APPLICATION_ERROR(-20016,
                    '[-20016] COCAO_RESERVA/T14: Transição de status inválida. ' ||
                    'De ABERTA para ' || :NEW.CODIGO_STATUS || ' não é permitido. Permitidos: ATIVA, A_PAGAR, CANCELADA. ' ||
                    'Escolha um status válido.');
            END IF;
        WHEN 2 THEN -- ATIVA
            IF :NEW.CODIGO_STATUS NOT IN (3, 4) THEN -- A_PAGAR, FINALIZADA
                RAISE_APPLICATION_ERROR(-20017,
                    '[-20017] COCAO_RESERVA/T14: Transição de status inválida. ' ||
                    'De ATIVA para ' || :NEW.CODIGO_STATUS || ' não é permitido. Permitidos: A_PAGAR, FINALIZADA. ' ||
                    'Escolha um status válido.');
            END IF;
            IF :NEW.CODIGO_STATUS = 4 AND TRUNC(:OLD.DATA_CHECK_OUT) > TRUNC(SYSDATE) THEN
                RAISE_APPLICATION_ERROR(-20024,
                    '[-20024] COCAO_RESERVA/T14: Finalização prematura bloqueada. ' ||
                    'Reserva ID ' || :OLD.ID_RESERVA || ' tem check-out em ' ||
                    TO_CHAR(:OLD.DATA_CHECK_OUT, 'DD/MM/YYYY') || '. ' ||
                    'A reserva só pode ser FINALIZADA após a data de check-out.');
            END IF;
        WHEN 3 THEN -- A_PAGAR
            IF :NEW.CODIGO_STATUS NOT IN (4, 5) THEN -- FINALIZADA, CANCELADA
                RAISE_APPLICATION_ERROR(-20018,
                    '[-20018] COCAO_RESERVA/T14: Transição de status inválida. ' ||
                    'De A_PAGAR para ' || :NEW.CODIGO_STATUS || ' não é permitido. Permitidos: FINALIZADA, CANCELADA. ' ||
                    'Escolha um status válido.');
            END IF;
            IF :NEW.CODIGO_STATUS = 4 AND TRUNC(:OLD.DATA_CHECK_OUT) > TRUNC(SYSDATE) THEN
                RAISE_APPLICATION_ERROR(-20024,
                    '[-20024] COCAO_RESERVA/T14: Finalização prematura bloqueada. ' ||
                    'Reserva ID ' || :OLD.ID_RESERVA || ' tem check-out em ' ||
                    TO_CHAR(:OLD.DATA_CHECK_OUT, 'DD/MM/YYYY') || '. ' ||
                    'A reserva só pode ser FINALIZADA após a data de check-out.');
            END IF;
        WHEN 4 THEN -- FINALIZADA
            RAISE_APPLICATION_ERROR(-20023,
                '[-20023] COCAO_RESERVA/T14: Alteração de status bloqueada. ' ||
                'Reserva ID ' || :OLD.ID_RESERVA || ' está FINALIZADA (estado terminal). ' ||
                'Nenhuma alteração de status é permitida.');
        WHEN 5 THEN -- CANCELADA
            RAISE_APPLICATION_ERROR(-20023,
                '[-20023] COCAO_RESERVA/T14: Alteração de status bloqueada. ' ||
                'Reserva ID ' || :OLD.ID_RESERVA || ' está CANCELADA (estado terminal). ' ||
                'Nenhuma alteração de status é permitida.');
        ELSE
            RAISE_APPLICATION_ERROR(-20012,
                '[-20012] COCAO_RESERVA/T14: Status inválido. ' ||
                'CODIGO_STATUS ' || :OLD.CODIGO_STATUS || ' não reconhecido. ' ||
                'Verifique o status da reserva.');
    END CASE;
END;
/

-- ======================================================================
-- T15: COCAO_RESERVA - Validação de Conflitos e Capacidade
-- ======================================================================
-- Valida conflitos temporais, capacidade do quarto e status MANUTENCAO
-- Usa SELECT ... FOR UPDATE para prevenir race conditions (double-booking)
-- Usa CODIGO_STATUS NUMBER(1) para consistência com COCAO_STATUS_RESERVA
-- NOTA: O front-end deve validar conflitos antes de enviar ao banco para evitar bloqueios
-- Novo:
--   - Removida atribuição redundante de NUMERO_DIARIAS, agora garantida pela constraint
--     CHK_COCAO_RESERVA_DIARIAS
--   - Mantida validação de MANUTENCAO, capacidade e conflitos de reservas
--   - Índice COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA melhora performance
--   - Mantido JOIN com CODIGO_TIPO_QUARTO para capacidade
--   - Simplificado para hotel pequeno, sem validações adicionais de manutenção futura
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_15_TRG_RESERVA_CONFLITO
BEFORE INSERT OR UPDATE OF DATA_CHECK_IN, DATA_CHECK_OUT, ID_QUARTO, NUMERO_HOSPEDES ON COCAO_RESERVA
FOR EACH ROW
DECLARE
    v_status_quarto COCAO_QUARTO.STATUS_QUARTO%TYPE;
    v_capacidade_maxima COCAO_TIPO_QUARTO.CAPACIDADE_MAXIMA%TYPE;
    v_count_conflitos NUMBER;
BEGIN
    -- Validar número de hóspedes
    IF :NEW.NUMERO_HOSPEDES <= 0 THEN
        RAISE_APPLICATION_ERROR(-20025,
            '[-20025] COCAO_RESERVA/T15: Número de hóspedes inválido. ' ||
            'NUMERO_HOSPEDES (' || :NEW.NUMERO_HOSPEDES || ') deve ser maior que 0. ' ||
            'Ajuste o número de hóspedes.');
    END IF;
    
    :NEW.DATA_CHECK_IN := TRUNC(:NEW.DATA_CHECK_IN);
    :NEW.DATA_CHECK_OUT := TRUNC(:NEW.DATA_CHECK_OUT);
    :NEW.NUMERO_DIARIAS := TRUNC(:NEW.DATA_CHECK_OUT) - TRUNC(:NEW.DATA_CHECK_IN);
    
    SELECT q.STATUS_QUARTO, qt.CAPACIDADE_MAXIMA
    INTO v_status_quarto, v_capacidade_maxima
    FROM COCAO_QUARTO q
    JOIN COCAO_TIPO_QUARTO qt ON q.CODIGO_TIPO_QUARTO = qt.CODIGO_TIPO_QUARTO
    WHERE q.ID_QUARTO = :NEW.ID_QUARTO;
    
    IF v_status_quarto = 'MANUTENCAO' THEN
        RAISE_APPLICATION_ERROR(-20014,
            '[-20014] COCAO_RESERVA/T15: Reserva bloqueada. ' ||
            'Quarto ID ' || :NEW.ID_QUARTO || ' está em manutenção no período solicitado. ' ||
            'Escolha outro quarto.');
    END IF;
    
    IF :NEW.NUMERO_HOSPEDES > v_capacidade_maxima THEN
        RAISE_APPLICATION_ERROR(-20015,
            '[-20015] COCAO_RESERVA/T15: Capacidade excedida. ' ||
            'Número de hóspedes (' || :NEW.NUMERO_HOSPEDES || ') excede a capacidade máxima (' ||
            v_capacidade_maxima || ') do quarto ID ' || :NEW.ID_QUARTO || '. ' ||
            'Ajuste o número de hóspedes ou escolha outro quarto.');
    END IF;
    
    SELECT COUNT(*)
    INTO v_count_conflitos
    FROM COCAO_RESERVA r
    WHERE r.ID_QUARTO = :NEW.ID_QUARTO
      AND r.CODIGO_STATUS IN (1, 2)
      AND r.ID_RESERVA != NVL(:NEW.ID_RESERVA, -1)
      AND TRUNC(r.DATA_CHECK_OUT) > TRUNC(:NEW.DATA_CHECK_IN)
      AND TRUNC(r.DATA_CHECK_IN) < TRUNC(:NEW.DATA_CHECK_OUT);
    
    IF v_count_conflitos > 0 THEN
        RAISE_APPLICATION_ERROR(-20016,
            '[-20016] COCAO_RESERVA/T15: Conflito de reserva. ' ||
            'Quarto ID ' || :NEW.ID_QUARTO || ' possui ' || v_count_conflitos ||
            ' reserva(s) ativa(s) ou aberta(s) no período de ' ||
            TO_CHAR(:NEW.DATA_CHECK_IN, 'DD/MM/YYYY') || ' a ' ||
            TO_CHAR(:NEW.DATA_CHECK_OUT, 'DD/MM/YYYY') || '. ' ||
            'Escolha outro quarto ou período.');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20013,
            '[-20013] COCAO_RESERVA/T15: Quarto não encontrado. ' ||
            'Quarto ID ' || :NEW.ID_QUARTO || ' ou tipo de quarto associado não existe. ' ||
            'Verifique o ID do quarto na reserva.');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20019,
            '[-20019] COCAO_RESERVA/T15: Erro inesperado ao validar reserva. ' ||
            'Erro: ' || SQLERRM);
END;
/

-- ======================================================================
-- T16: COCAO_SERVICO - Atualiza VALOR_TOTAL de Reservas
-- ======================================================================
-- Objetivo: Recalcula VALOR_TOTAL para reservas ABERTA (1) ou ATIVA (2) que usam
--           o serviço alterado, considerando a nova coluna ID_RESERVA.
-- Justificativa: Garante que serviços sejam associados à reserva correta, evitando
--                inclusão de serviços de outras reservas do mesmo hóspede.
-- Funcionamento:
-- - Calcula VALOR_TOTAL como: (VALOR_DIARIA × NUMERO_DIARIAS) + (Soma de serviços
--   associados à reserva, com DATA_SOLICITACAO no período da reserva).
-- - Usa FOR UPDATE WAIT 5 para evitar deadlocks prolongados.
-- - Índice COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO melhora performance.
-- Instruções para o front-end:
-- - Certifique-se de que COCAO_HOSPEDE_SERVICO.ID_RESERVA está preenchido
--   corretamente ao inserir serviços.
-- - VALOR_TOTAL é atualizado automaticamente após alterações no PRECO de um serviço.
-- Novo:
-- - Ajustado para usar ID_RESERVA em COCAO_HOSPEDE_SERVICO, garantindo que apenas
--   serviços da reserva correta sejam considerados no cálculo.
-- - Mantida lógica de considerar apenas reservas ABERTA (1) ou ATIVA (2).
-- - Adicionados comentários instrucionais para esclarecer o uso de ID_RESERVA.
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_16_TRG_ATUALIZA_SERVICO
AFTER UPDATE OF PRECO ON COCAO_SERVICO
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    -- Verificar se há reservas afetadas
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA r
    WHERE r.CODIGO_STATUS IN (1, 2)
      AND EXISTS (
          SELECT 1
          FROM COCAO_HOSPEDE_SERVICO hs
          WHERE hs.ID_RESERVA = r.ID_RESERVA
            AND hs.CODIGO_SERVICO = :NEW.CODIGO_SERVICO
            AND TRUNC(hs.DATA_SOLICITACAO) >= TRUNC(r.DATA_CHECK_IN)
            AND TRUNC(hs.DATA_SOLICITACAO) < TRUNC(r.DATA_CHECK_OUT)
      );
    
    -- Apenas atualizar se houver reservas afetadas
    IF v_count > 0 THEN
        UPDATE COCAO_RESERVA r
        SET VALOR_TOTAL = (
            SELECT t.VALOR_DIARIA * r.NUMERO_DIARIAS
            FROM COCAO_QUARTO q
            JOIN COCAO_TIPO_QUARTO t ON q.CODIGO_TIPO_QUARTO = t.CODIGO_TIPO_QUARTO
            WHERE q.ID_QUARTO = r.ID_QUARTO
        ) + COALESCE((
            SELECT SUM(s.PRECO * hs.QUANTIDADE)
            FROM COCAO_HOSPEDE_SERVICO hs
            JOIN COCAO_SERVICO s ON hs.CODIGO_SERVICO = s.CODIGO_SERVICO
            WHERE hs.ID_RESERVA = r.ID_RESERVA
              AND TRUNC(hs.DATA_SOLICITACAO) >= TRUNC(r.DATA_CHECK_IN)
              AND TRUNC(hs.DATA_SOLICITACAO) < TRUNC(r.DATA_CHECK_OUT)
        ), 0)
        WHERE r.CODIGO_STATUS IN (1, 2)
          AND EXISTS (
              SELECT 1
              FROM COCAO_HOSPEDE_SERVICO hs
              WHERE hs.ID_RESERVA = r.ID_RESERVA
                AND hs.CODIGO_SERVICO = :NEW.CODIGO_SERVICO
                AND TRUNC(hs.DATA_SOLICITACAO) >= TRUNC(r.DATA_CHECK_IN)
                AND TRUNC(hs.DATA_SOLICITACAO) < TRUNC(r.DATA_CHECK_OUT)
          )
        FOR UPDATE WAIT 5;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20042,
            '[-20042] COCAO_SERVICO/T16: Falha ao calcular VALOR_TOTAL. ' ||
            'Quarto, tipo de quarto ou serviço associado à reserva não encontrado. ' ||
            'Verifique as tabelas COCAO_QUARTO, COCAO_TIPO_QUARTO e COCAO_HOSPEDE_SERVICO.');
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_SERVICO/T16: Tempo de espera excedido para bloqueio da reserva. ' ||
                'Serviço CODIGO_SERVICO ' || :NEW.CODIGO_SERVICO || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_SERVICO/T16: Erro inesperado ao atualizar VALOR_TOTAL. ' ||
                'Erro: ' || SQLERRM);
        END IF;
END;
/

-- ======================================================================
-- T17: COCAO_HOSPEDE_SERVICO - Atualiza VALOR_TOTAL da Reserva
-- ======================================================================
-- Objetivo: Recalcula VALOR_TOTAL para reservas ABERTA (1) ou ATIVA (2) após
--           INSERT, UPDATE ou DELETE em COCAO_HOSPEDE_SERVICO, usando ID_RESERVA.
-- Justificativa: Garante que apenas serviços associados à reserva correta sejam
--                incluídos no cálculo de VALOR_TOTAL.
-- Funcionamento:
-- - Calcula VALOR_TOTAL como: (VALOR_DIARIA × NUMERO_DIARIAS) + (Soma de serviços
--   associados à reserva, com DATA_SOLICITACAO no período da reserva).
-- - Usa FOR UPDATE WAIT 5 para evitar deadlocks prolongados.
-- - Índice COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO melhora performance.
-- Instruções para o front-end:
-- - Forneça ID_RESERVA ao inserir ou atualizar em COCAO_HOSPEDE_SERVICO.
-- - VALOR_TOTAL é atualizado automaticamente após operações em COCAO_HOSPEDE_SERVICO.
-- Novo:
-- - Ajustado para usar ID_RESERVA em COCAO_HOSPEDE_SERVICO, garantindo precisão.
-- - Mantida lógica de considerar apenas reservas ABERTA (1) ou ATIVA (2).
-- - Adicionados comentários instrucionais para esclarecer o uso de ID_RESERVA.
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_17_TRG_ATUALIZA_RESERVA
AFTER INSERT OR UPDATE OR DELETE ON COCAO_HOSPEDE_SERVICO
FOR EACH ROW
DECLARE
    v_id_reserva COCAO_RESERVA.ID_RESERVA%TYPE;
    v_count NUMBER;
BEGIN
    v_id_reserva := CASE WHEN DELETING THEN :OLD.ID_RESERVA ELSE :NEW.ID_RESERVA END;
    
    -- Verificar se ID_RESERVA existe
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA
    WHERE ID_RESERVA = v_id_reserva;
    
    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20049,
            '[-20049] COCAO_HOSPEDE_SERVICO/T17: Reserva não encontrada. ' ||
            'ID_RESERVA ' || v_id_reserva || ' não existe em COCAO_RESERVA. ' ||
            'Verifique o ID da reserva.');
    END IF;
    
    -- Verificar se a reserva está em estado ABERTA (1) ou ATIVA (2)
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA
    WHERE ID_RESERVA = v_id_reserva
      AND CODIGO_STATUS IN (1, 2);
    
    -- Apenas atualizar se a reserva for válida
    IF v_count > 0 THEN
        UPDATE COCAO_RESERVA r
        SET VALOR_TOTAL = (
            SELECT t.VALOR_DIARIA * r.NUMERO_DIARIAS
            FROM COCAO_QUARTO q
            JOIN COCAO_TIPO_QUARTO t ON q.CODIGO_TIPO_QUARTO = t.CODIGO_TIPO_QUARTO
            WHERE q.ID_QUARTO = r.ID_QUARTO
        ) + COALESCE((
            SELECT SUM(s.PRECO * hs.QUANTIDADE)
            FROM COCAO_HOSPEDE_SERVICO hs
            JOIN COCAO_SERVICO s ON hs.CODIGO_SERVICO = s.CODIGO_SERVICO
            WHERE hs.ID_RESERVA = r.ID_RESERVA
              AND TRUNC(hs.DATA_SOLICITACAO) >= TRUNC(r.DATA_CHECK_IN)
              AND TRUNC(hs.DATA_SOLICITACAO) < TRUNC(r.DATA_CHECK_OUT)
        ), 0)
        WHERE r.ID_RESERVA = v_id_reserva
          AND r.CODIGO_STATUS IN (1, 2)
        FOR UPDATE WAIT 5;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20044,
            '[-20044] COCAO_HOSPEDE_SERVICO/T17: Falha ao calcular VALOR_TOTAL. ' ||
            'Quarto, tipo de quarto ou serviço não encontrado. ' ||
            'Verifique as tabelas COCAO_QUARTO, COCAO_TIPO_QUARTO e COCAO_HOSPEDE_SERVICO.');
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_HOSPEDE_SERVICO/T17: Tempo de espera excedido para bloqueio da reserva. ' ||
                'Reserva ID ' || v_id_reserva || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_HOSPEDE_SERVICO/T17: Erro inesperado ao atualizar VALOR_TOTAL. ' ||
                'Erro: ' || SQLERRM);
        END IF;
END;
/

-- ======================================================================
-- T18: COCAO_HOSPEDE_SERVICO - Validação de Serviço Ativo
-- ======================================================================
-- Objetivo: Garante que os serviços solicitados estejam ativos em COCAO_SERVICO
--           e associados a uma reserva ABERTA (1) ou ATIVA (2) com
--           DATA_SOLICITACAO no período da reserva. Valida ID_RESERVA.
-- Justificativa: Reforça a integridade ao associar serviços diretamente à reserva
--                correta, usando a nova coluna ID_RESERVA.
-- Funcionamento:
-- - Verifica se o serviço está ativo (ATIVO = 1).
-- - Verifica se ID_RESERVA existe e corresponde a uma reserva ABERTA ou ATIVA
--   com DATA_SOLICITACAO no período da reserva.
-- - Índice COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO melhora performance.
-- Instruções para o front-end:
-- - Forneça ID_RESERVA ao inserir ou atualizar em COCAO_HOSPEDE_SERVICO.
-- - Valide ID_RESERVA antes de enviar ao banco, usando:
--   SELECT ID_RESERVA
--   FROM COCAO_RESERVA
--   WHERE ID_RESERVA = :id_reserva
--     AND CODIGO_STATUS IN (1, 2)
--     AND TRUNC(:data_solicitacao) >= TRUNC(DATA_CHECK_IN)
--     AND TRUNC(:data_solicitacao) < TRUNC(DATA_CHECK_OUT);
-- - Se ID_RESERVA for inválido, exiba erro ao usuário antes de inserir.
-- Novo:
-- - Adicionada validação de ID_RESERVA para garantir associação correta.
-- - Removida menção a unicidade por dia, permitindo múltiplos pedidos do mesmo
--   serviço no mesmo dia.
-- - Adicionados comentários instrucionais para o front-end.
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_18_TRG_SERVICO_ATIVO
BEFORE INSERT OR UPDATE ON COCAO_HOSPEDE_SERVICO
FOR EACH ROW
DECLARE
    v_ativo COCAO_SERVICO.ATIVO%TYPE;
    v_count NUMBER;
BEGIN
    -- Validar quantidade
    IF :NEW.QUANTIDADE > 100 THEN
        RAISE_APPLICATION_ERROR(-20047,
            '[-20047] COCAO_HOSPEDE_SERVICO/T18: Quantidade inválida. ' ||
            'A quantidade solicitada (' || :NEW.QUANTIDADE || ') excede o limite máximo de 100 unidades. ' ||
            'Ajuste a quantidade solicitada.');
    END IF;
    
    -- Validar se o serviço está ativo
    SELECT ATIVO
    INTO v_ativo
    FROM COCAO_SERVICO
    WHERE CODIGO_SERVICO = :NEW.CODIGO_SERVICO;
    
    IF v_ativo = 0 THEN
        RAISE_APPLICATION_ERROR(-20045,
            '[-20045] COCAO_HOSPEDE_SERVICO/T18: Solicitação de serviço bloqueada. ' ||
            'Serviço CODIGO_SERVICO ' || :NEW.CODIGO_SERVICO || ' está inativo. ' ||
            'Escolha um serviço ativo.');
    END IF;
    
    -- Validar se ID_RESERVA existe e está associado a uma reserva válida
    SELECT COUNT(*)
    INTO v_count
    FROM COCAO_RESERVA r
    WHERE r.ID_RESERVA = :NEW.ID_RESERVA
      AND r.CODIGO_STATUS IN (1, 2) -- ABERTA, ATIVA
      AND TRUNC(:NEW.DATA_SOLICITACAO) >= TRUNC(r.DATA_CHECK_IN)
      AND TRUNC(:NEW.DATA_SOLICITACAO) < TRUNC(r.DATA_CHECK_OUT);
    
    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20046,
            '[-20046] COCAO_HOTEL_18_TRG_SERVICO_ATIVO: Solicitação de serviço inválida. ' ||
            'Reserva ID ' || :NEW.ID_RESERVA || ' não é uma reserva aberta ou ativa na data de solicitação ' ||
            TO_CHAR(TRUNC(:NEW.DATA_SOLICITACAO), 'DD/MM/YYYY') || '. ' ||
            'Garanta que o ID_RESERVA corresponda a uma reserva válida no período solicitado.');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20048,
            '[-20048] COCAO_HOTEL_18_TRG_SERVICO_ATIVO: Falha na validação de serviço. ' ||
            'Serviço CODIGO_SERVICO ' || :NEW.CODIGO_SERVICO || ' ou Reserva ID ' || :NEW.ID_RESERVA || 
            ' não encontrado. Verifique o código do serviço e o ID da reserva.');
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_HOSPEDE_SERVICO/T18: Tempo de espera excedido para bloqueio da reserva. ' ||
                'Reserva ID ' || :NEW.ID_RESERVA || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_HOSPEDE_SERVICO/T18: Erro inesperado ao validar serviço. ' ||
                'Erro: ' || SQLERRM);
        END IF;
END;
/

-- ======================================================================
-- T19: COCAO_FUNCIONARIO - Validação de TIPO=1 em COCAO_HOSPEDE
-- ======================================================================
-- Garante que registros em COCAO_FUNCIONARIO tenham TIPO=1 em COCAO_HOSPEDE
-- Novo: Adicionado para corrigir falta de validação de herança.
-- Nota: Não usa COCAO_HOTEL_CONSTANTS, permanece inalterado.
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_19_TRG_FUNCIONARIO_TIPO
BEFORE INSERT OR UPDATE ON COCAO_FUNCIONARIO
FOR EACH ROW
DECLARE
    v_tipo COCAO_HOSPEDE.TIPO%TYPE;
BEGIN
    SELECT TIPO
    INTO v_tipo
    FROM COCAO_HOSPEDE
    WHERE ID_USUARIO = :NEW.ID_USUARIO;
    
    IF v_tipo != 1 THEN
        RAISE_APPLICATION_ERROR(-20050,
            '[-20050] COCAO_FUNCIONARIO/T19: Inconsistência de tipo. ' ||
            'Hóspede ID ' || :NEW.ID_USUARIO || ' deve ter TIPO=1 em COCAO_HOSPEDE para ser funcionário. ' ||
            'Atualize o TIPO em COCAO_HOSPEDE antes de inserir/atualizar.');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20051,
            '[-20051] COCAO_FUNCIONARIO/T19: Hóspede não encontrado. ' ||
            'ID_USUARIO ' || :NEW.ID_USUARIO || ' não existe em COCAO_HOSPEDE. ' ||
            'Verifique o ID do hóspede.');
END;
/
-- ======================================================================
-- T20: COCAO_RESERVA - Recálculo de VALOR_TOTAL após Alterações Críticas
-- ======================================================================
-- Objetivo: Garante que VALOR_TOTAL em COCAO_RESERVA seja recalculado automaticamente
--           após alterações em DATA_CHECK_IN, DATA_CHECK_OUT ou ID_QUARTO, para
--           reservas ABERTA (1) ou ATIVA (2), refletindo o custo exato das diárias
--           e serviços associados no período da reserva.
-- Justificativa: Mantém a integridade financeira do sistema, atualizando o custo total
--                com base no VALOR_DIARIA do quarto (via COCAO_TIPO_QUARTO) e na
--                soma dos serviços (PRECO * QUANTIDADE) em COCAO_HOSPEDE_SERVICO,
--                considerando apenas serviços dentro do período da reserva.
-- Funcionamento:
-- - Disparado APÓS atualizações em DATA_CHECK_IN, DATA_CHECK_OUT ou ID_QUARTO.
-- - Calcula VALOR_TOTAL = (VALOR_DIARIA × NUMERO_DIARIAS) + (Soma de serviços
--   associados à reserva, com DATA_SOLICITACAO no período [DATA_CHECK_IN, DATA_CHECK_OUT)).
-- - Usa FOR UPDATE WAIT 5 para evitar deadlocks prolongados em cenários concorrentes.
-- - Índice COCAO_HOTEL_07_IDX_STATUS_QUARTO_RESERVA otimiza consultas a COCAO_RESERVA.
-- - Índice COCAO_HOTEL_09_IDX_HOSPEDE_SERVICO otimiza consultas a COCAO_HOSPEDE_SERVICO.
-- Dependências:
-- - Requer que T15 tenha atualizado NUMERO_DIARIAS antes do recálculo.
-- - Assume que COCAO_QUARTO, COCAO_TIPO_QUARTO e COCAO_HOSPEDE_SERVICO estejam íntegros.
-- Instruções para o front-end:
-- - Antes de atualizar DATA_CHECK_IN, DATA_CHECK_OUT ou ID_QUARTO, valide conflitos
--   de reserva usando a consulta sugerida em COCAO_RESERVA (ver comentários da tabela).
-- - VALOR_TOTAL é atualizado automaticamente por este trigger; não é necessário
--   recalculá-lo no front-end.
-- - Capture erros [-20044] (dados não encontrados) ou [-20019] (timeout/erro genérico)
--   e exiba mensagens claras ao usuário, sugerindo verificação de quarto ou retry.
-- Exemplo de uso:
--   UPDATE COCAO_RESERVA
--   SET DATA_CHECK_OUT = TO_DATE('04/01/2026', 'DD/MM/YYYY')
--   WHERE ID_RESERVA = 1;
--   -- VALOR_TOTAL será atualizado para (VALOR_DIARIA * 3) + (Soma de serviços).
-- Novo (v15.0):
-- - Ajustado para usar ID_RESERVA em COCAO_HOSPEDE_SERVICO, garantindo que apenas
--   serviços da reserva correta sejam considerados.
-- - Mantida lógica de considerar apenas reservas ABERTA (1) ou ATIVA (2).
-- - Adicionado FOR UPDATE WAIT 5 para consistência com T12, T13, T15, T16, T17.
-- Nota Épica: Este trigger é o guardião financeiro do Hotel Cocão! Ele assegura que
--             o VALOR_TOTAL reflete cada mudança no período ou quarto da reserva,
--             mantendo a conta certinha para hóspedes e gerentes, sem deixar espaço
--             para surpresas no check-out. Respeite o T20: ele calcula, protege e
--             nunca dorme no ponto!
-- ======================================================================
CREATE OR REPLACE TRIGGER COCAO_HOTEL_20_TRG_RESERVA_VALOR_RECALCULADO
AFTER UPDATE OF DATA_CHECK_IN, DATA_CHECK_OUT, ID_QUARTO ON COCAO_RESERVA
FOR EACH ROW
BEGIN
    -- Atualizar VALOR_TOTAL apenas para reservas ABERTA (1) ou ATIVA (2)
    IF :NEW.CODIGO_STATUS IN (1, 2) THEN
        UPDATE COCAO_RESERVA r
        SET VALOR_TOTAL = (
            SELECT t.VALOR_DIARIA * :NEW.NUMERO_DIARIAS
            FROM COCAO_QUARTO q
            JOIN COCAO_TIPO_QUARTO t ON q.CODIGO_TIPO_QUARTO = t.CODIGO_TIPO_QUARTO
            WHERE q.ID_QUARTO = :NEW.ID_QUARTO
        ) + COALESCE((
            SELECT SUM(s.PRECO * hs.QUANTIDADE)
            FROM COCAO_HOSPEDE_SERVICO hs
            JOIN COCAO_SERVICO s ON hs.CODIGO_SERVICO = s.CODIGO_SERVICO
            WHERE hs.ID_RESERVA = :NEW.ID_RESERVA
              AND TRUNC(hs.DATA_SOLICITACAO) >= TRUNC(:NEW.DATA_CHECK_IN)
              AND TRUNC(hs.DATA_SOLICITACAO) < TRUNC(:NEW.DATA_CHECK_OUT)
        ), 0)
        WHERE r.ID_RESERVA = :NEW.ID_RESERVA
        FOR UPDATE WAIT 5;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20044,
            '[-20044] COCAO_RESERVA/T20: Falha ao calcular VALOR_TOTAL. ' ||
            'Quarto, tipo de quarto ou serviço não encontrado. ' ||
            'Verifique as tabelas COCAO_QUARTO, COCAO_TIPO_QUARTO e COCAO_HOSPEDE_SERVICO.');
    WHEN OTHERS THEN
        IF SQLCODE = -00054 THEN
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_RESERVA/T20: Tempo de espera excedido para bloqueio da reserva. ' ||
                'Reserva ID ' || :NEW.ID_RESERVA || ' está bloqueado por outra transação. ' ||
                'Tente novamente mais tarde.');
        ELSE
            RAISE_APPLICATION_ERROR(-20019,
                '[-20019] COCAO_RESERVA/T20: Erro inesperado ao atualizar VALOR_TOTAL. ' ||
                'Erro: ' || SQLERRM);
        END IF;
END;
/