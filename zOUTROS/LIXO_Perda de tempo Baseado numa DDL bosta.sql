create or replace PROCEDURE A_PERDA_DE_TEMPO_01 (
    P_TOTAL_SERVICO_OUT    OUT NUMBER, -- Total acumulado dos serviços vendidos (HTL_RESERVA_SERVICO)
    P_TOTAL_DIARIAS_OUT    OUT NUMBER  -- Total acumulado do valor contratado das reservas (HTL_RESERVA)
)
AS
-- SP simples para retornar o total acumulado de serviços e o total acumulado de diárias contratadas.
BEGIN
-- 1. Calcular o total acumulado dos serviços
    SELECT SUM(VALOR)
    INTO P_TOTAL_SERVICO_OUT
    FROM HTL_RESERVA_SERVICO;

    -- 2. Calcular o total acumulado do valor contratado das reservas
    SELECT SUM(VALOR_CONTRATADO)
    INTO P_TOTAL_DIARIAS_OUT
    FROM HTL_RESERVA;

    -- Exibe o resultado da execução no console
    DBMS_OUTPUT.PUT_LINE('Cálculo de Totais Financeiros Concluído:');
    DBMS_OUTPUT.PUT_LINE('Total em Serviços: R$ ' || TO_CHAR(P_TOTAL_SERVICO_OUT, '999G999D00'));
    DBMS_OUTPUT.PUT_LINE('Total em Diárias Contratadas: R$ ' || TO_CHAR(P_TOTAL_DIARIAS_OUT, '999G999D00'));

/*
-- ==========================================
-- TUTORIAL E TESTE: A_PERDA_DE_TEMPO_01
-- ==========================================

    -- 1. Ativar o modo de exibição de saída do console
    SET SERVEROUTPUT ON;

    -- 2. Configurar caracteres numéricos para a sessão
    ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,';  -- Define separador de milhar e decimal

    -- 3. Bloco PL/SQL para chamar o SP
    -- Sem TO_CHAR: O número será mostrado sem formatação extra.
    -- Com TO_CHAR: Você pode formatar o número (ex: colocar separador de milhar, casas decimais, ou símbolos específicos como "R$").

DECLARE
    -- Variáveis para receber os valores retornados (OBRIGATÓRIO)
    V_TOTAL_SERVICO_OUT  NUMBER;
    V_TOTAL_DIARIAS_OUT  NUMBER;

    -- Cálculos Esperados (baseados no seu DML 20-10-2025):
    -- Serviços (Café 35 + Lavanderia 25 + Quarto 40 + Spa 180 + Jantar 70) = 350.00
    -- Diárias (Reserva 1: 440 + Reserva 2: 1400 + Reserva 3: 1050 + Reserva 4: 1000) = 3890.00

BEGIN
    -- Chamada do Stored Procedure
    A_PERDA_DE_TEMPO_01(
        P_TOTAL_SERVICO_OUT => V_TOTAL_SERVICO_OUT,
        P_TOTAL_DIARIAS_OUT => V_TOTAL_DIARIAS_OUT
    );

    DBMS_OUTPUT.PUT_LINE('--- Verificação no Bloco Anonimo ---');
    DBMS_OUTPUT.PUT_LINE('Total Serviços Retornado: R$ ' || TO_CHAR(V_TOTAL_SERVICO_OUT, '999G999D00'));
    DBMS_OUTPUT.PUT_LINE('Total Diárias Retornado:  R$ ' || TO_CHAR(V_TOTAL_DIARIAS_OUT, '999G999D00'));
END;


-- ==========================================
-- PROVA 01 - PERGUNTAS E RESPOSTAS
-- ==========================================

-- 1 - Criar nova tabela HTL_SERVICO_QTDE. Devem ser criados os campos ID_HTL_SERVICO_QTDE como chave 
-- primária (NUMBER, atualizado automaticamente ou pela sequence SEQ_HTL_SERVICO_QTDE), DATA_SERVICO (DATE) e QTDE_SERVICO(NUMBER(5,0)). 
-- Além disso, você deve analisar o relacionamento com as demais tabelas e criar a(s) coluna(as) e chave(s) estrangeira(s) apropriada(s). 
-- O objetivo é armazenar a quantidade total de um determinado serviço para TODOS as reservas realizados em uma determinada DATA.

-- =====================
-- 1 - Tabela: HTL_SERVICO_QTDE
-- =====================
CREATE TABLE HTL_SERVICO_QTDE (
    -- ID de controle interno (chave substituta)
    ID_HTL_SERVICO_QTDE    INTEGER GENERATED BY DEFAULT AS IDENTITY,

    -- Qual serviço está sendo contado (chave estrangeira)
    SERVICO_ID             INTEGER        NOT NULL,

    -- Data em que a contagem ocorreu
    DATA_SERVICO           DATE           NOT NULL,

    -- Quantidade total de vezes que o serviço foi utilizado naquela data
    QTDE_SERVICO           NUMBER(5,0)    NOT NULL,

    -- Chave Primária (conforme especificado)
    CONSTRAINT PK_HTL_SERVICO_QTDE PRIMARY KEY (ID_HTL_SERVICO_QTDE),

    -- Chave Estrangeira: Referência à tabela de serviços
    CONSTRAINT FK_HTL_SQ_SERVICO FOREIGN KEY (SERVICO_ID)
        REFERENCES HTL_SERVICO (SERVICO_ID),

    -- ***************************************************************
    -- NOVO/REINCLUÍDO: Restrição de Unicidade
    -- POR QUE? Para garantir que NÃO EXISTAM LINHAS DUPLICADAS.
    -- O objetivo da tabela é ter APENAS UMA linha para a combinação
    -- Serviço X Data.
    -- Esta chave é crucial para a integridade dos dados e para que a lógica
    -- de 'MERGE' funcione corretamente no próximo passo.
    -- Caso contrário, você teria múltiplas linhas de "Café da manhã: 1" em "2025-09-16".
    -- ***************************************************************
    CONSTRAINT UK_HTL_SQ_SERVICO_DATA UNIQUE (SERVICO_ID, DATA_SERVICO)
);
*/


-- ==========================================
-- 2 - Crie um Stored Procedure para inserir registros na tabela HTL_SERVICO_QTDE considerando 
-- as reservas existentes com suas datas e serviços cadastrados. (Sugestão: Use INSERT com SELECT)
-- ==========================================

-- O SP abaixo embora vá funcionar, ele vai DUPLICAR os dados

-- Abaixo a resposta da PERGUNTA, mas não a melhor forma de trabalhar com STORED PROCEDURE

/*
CREATE OR REPLACE PROCEDURE SP_HTL_INSERIR_SERVICO_QTDE (
    p_registros_inseridos_out OUT INTEGER -- Retorna o número de linhas inseridas
)
AS
-- Este procedimento insere o total (QTDE) de cada SERVIÇO vendido em cada DATA
-- (agregando dados de todas as reservas), na tabela HTL_SERVICO_QTDE.
BEGIN
    -- 1. Insere os dados na tabela HTL_SERVICO_QTDE
    INSERT INTO HTL_SERVICO_QTDE (
        SERVICO_ID, 
        DATA_SERVICO, 
        QTDE_SERVICO
    )
    SELECT
        T1.SERVICO_ID,
        -- TRUNC é usado para remover a parte da hora da coluna DATE, 
        -- garantindo que a agregação seja feita por dia completo.
        TRUNC(T1.CONCLUIDO_EM) AS DATA_SERVICO,
        COUNT(T1.SERVICO_ID) AS QTDE_SERVICO
    FROM
        HTL_RESERVA_SERVICO T1
    -- Agrupa pelo Serviço e pela Data em que foi concluído
    GROUP BY
        T1.SERVICO_ID,
        TRUNC(T1.CONCLUIDO_EM);

    -- 2. Captura o número de linhas afetadas e armazena no parâmetro de saída
    p_registros_inseridos_out := SQL%ROWCOUNT;

    -- 3. Confirma a transação
    COMMIT;

    -- Exibe o resultado da execução no console
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('Execução: SP_HTL_INSERIR_SERVICO_QTDE');
    DBMS_OUTPUT.PUT_LINE('Registros Inseridos na HTL_SERVICO_QTDE: ' || p_registros_inseridos_out);
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
*/
/*
-- ==========================================
-- TUTORIAL E TESTE: SP_HTL_INSERIR_SERVICO_QTDE
-- ==========================================

-- 1. Ativar o modo de exibição de saída do console
SET SERVEROUTPUT ON;

-- 2. Bloco PL/SQL para chamar o SP
DECLARE
    -- Variável para receber o valor retornado
    v_linhas_inseridas INTEGER;
BEGIN
    -- Chamada do Stored Procedure
    SP_HTL_INSERIR_SERVICO_QTDE(p_registros_inseridos_out => v_linhas_inseridas);

    DBMS_OUTPUT.PUT_LINE('Total de linhas inseridas retornado: ' || v_linhas_inseridas);

    -- Verifica os dados inseridos (deve mostrar 5 registros únicos):
    -- - Café da manhã (ID 1) em 2025-09-16 (1 ocorrência)
    -- - Lavanderia (ID 4) em 2025-09-16 (1 ocorrência)
    -- - Serviço de Quarto (ID 7) em 2025-09-16 (1 ocorrência)
    -- - Spa (ID 5) em 2025-09-23 (1 ocorrência)
    -- - Jantar (ID 3) em 2025-09-24 (1 ocorrência)

    -- Consulta para verificar os resultados
    DBMS_OUTPUT.PUT_LINE('--- Verificação dos Dados Inseridos ---');
    FOR rec IN (
        SELECT
            T1.ID_HTL_SERVICO_QTDE,
            T2.NOME AS SERVICO,
            TO_CHAR(T1.DATA_SERVICO, 'YYYY-MM-DD') AS DATA,
            T1.QTDE_SERVICO
        FROM
            HTL_SERVICO_QTDE T1
        JOIN
            HTL_SERVICO T2 ON T1.SERVICO_ID = T2.SERVICO_ID
        ORDER BY
            T1.DATA_SERVICO, T2.NOME
    )
    LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || rec.ID_HTL_SERVICO_QTDE || ' | Serviço: ' || rec.SERVICO || ' | Data: ' || rec.DATA || ' | Qtde: ' || rec.QTDE_SERVICO);
    END LOOP;

    -- NOTA: Se o SP for executado novamente, ele tentará inserir os mesmos dados
    -- e falhará (se a UK tivesse sido mantida) ou inserirá dados duplicados (como está agora).
END;
*/
/*
END SP_HTL_INSERIR_SERVICO_QTDE;
*/
/*
-- ==========================================
-- 2 - Melhor forma de Atualizar os dados
-- ==========================================

CREATE OR REPLACE PROCEDURE HTL_SP_SERVICO_ATUALIZA_QTDE (
    p_registros_afetados_out OUT INTEGER -- Retorna o número total de linhas ATUALIZADAS ou INSERIDAS
)
AS
-- Este procedimento usa MERGE para garantir que a tabela HTL_SERVICO_QTDE seja ATUALIZADA
-- com as quantidades de serviços por dia, evitando duplicatas e garantindo idempotência.

    -- Variável interna para rastrear o número de linhas afetadas pelo MERGE
    v_rows_affected INTEGER;
BEGIN
    -- Utiliza MERGE para UPSERT (UPDATE ou INSERT)
    MERGE INTO HTL_SERVICO_QTDE Destino
    USING (
        -- Fonte de dados: Subconsulta que calcula as agregações
        SELECT
            T1.SERVICO_ID,
            TRUNC(T1.CONCLUIDO_EM) AS DATA_SERVICO,
            COUNT(T1.SERVICO_ID) AS QTDE_TOTAL
        FROM
            HTL_RESERVA_SERVICO T1
        GROUP BY
            T1.SERVICO_ID,
            TRUNC(T1.CONCLUIDO_EM)
    ) Fonte
    ON (
        -- Condição de correspondência: O que define uma linha já existente
        Destino.SERVICO_ID = Fonte.SERVICO_ID AND
        Destino.DATA_SERVICO = Fonte.DATA_SERVICO
    )
    -- Se houver correspondência (já existe Serviço na Data), ATUALIZA a quantidade
    WHEN MATCHED THEN 
        UPDATE SET Destino.QTDE_SERVICO = Fonte.QTDE_TOTAL
    -- Se NÃO houver correspondência, INSERE a nova linha agregada
    WHEN NOT MATCHED THEN
        INSERT (Destino.SERVICO_ID, Destino.DATA_SERVICO, Destino.QTDE_SERVICO)
        VALUES (Fonte.SERVICO_ID, Fonte.DATA_SERVICO, Fonte.QTDE_TOTAL);

    -- Captura o número de linhas afetadas pelo MERGE
    v_rows_affected := SQL%ROWCOUNT;
    p_registros_afetados_out := v_rows_affected;

    COMMIT;

    DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('Execução: HTL_SP_SERVICO_ATUALIZA_QTDE');
    DBMS_OUTPUT.PUT_LINE('Registros (Inseridos/Atualizados): ' || v_rows_affected);
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
*/
/*
-- ==========================================
-- TUTORIAL E TESTE: HTL_SP_SERVICO_ATUALIZA_QTDE (Usando MERGE)
-- ==========================================

-- OBJETIVO: Testar as duas fases do MERGE (INSERT na 1ª execução e UPDATE na 2ª)

-- 1. Ativar o modo de exibição de saída do console
SET SERVEROUTPUT ON;

-- 2. BLOCO DE TESTE 1: PRIMEIRA EXECUÇÃO (Deve INSERIR 5 registros)
-- --------------------------------------------------------------------------------
DECLARE
    -- Variável para receber o valor retornado
    v_linhas_afetadas INTEGER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('INÍCIO DO TESTE 1: PRIMEIRA EXECUÇÃO (Esperado: 5 INSERTS)');

    -- Chamada do Stored Procedure (Executa o MERGE)
    HTL_SP_SERVICO_ATUALIZA_QTDE(p_registros_afetados_out => v_linhas_afetadas);

    DBMS_OUTPUT.PUT_LINE('Total de linhas afetadas retornado no Bloco: ' || v_linhas_afetadas);

    -- Neste ponto, a tabela HTL_SERVICO_QTDE deve ter 5 registros.

    DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');

END;

-- --------------------------------------------------------------------------------
-- BLOCO DE TESTE 2: SEGUNDA EXECUÇÃO (Deve ATUALIZAR 5 registros - Teste de Idempotência)
-- --------------------------------------------------------------------------------
DECLARE
    v_linhas_afetadas INTEGER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('INÍCIO DO TESTE 2: SEGUNDA EXECUÇÃO (Esperado: 5 UPDATES)');

    -- Chamada do Stored Procedure novamente
    HTL_SP_SERVICO_ATUALIZA_QTDE(p_registros_afetados_out => v_linhas_afetadas);

    DBMS_OUTPUT.PUT_LINE('Total de linhas afetadas retornado no Bloco: ' || v_linhas_afetadas);

    -- O número de linhas afetadas deve ser o mesmo (5), mas desta vez o MERGE
    -- executou o WHEN MATCHED (UPDATE) e NÃO o WHEN NOT MATCHED (INSERT).

    DBMS_OUTPUT.PUT_LINE('----------------------------------------------------');

END;

-- --------------------------------------------------------------------------------
-- BLOCO DE TESTE 3: VERIFICAÇÃO FINAL (Deve ter apenas 5 linhas no total)
-- --------------------------------------------------------------------------------

SELECT COUNT(*) AS TOTAL_LINHAS_NO_RESUMO FROM HTL_SERVICO_QTDE;
-- Resultado esperado: 5

-- Consulta detalhada para ver o resultado final
BEGIN
    DBMS_OUTPUT.PUT_LINE('--- Verificação dos Dados Finais ---');

    FOR rec IN (
        SELECT
            T1.ID_HTL_SERVICO_QTDE,
            T2.NOME AS SERVICO,
            TO_CHAR(T1.DATA_SERVICO, 'YYYY-MM-DD') AS DATA,
            T1.QTDE_SERVICO
        FROM
            HTL_SERVICO_QTDE T1
        JOIN
            HTL_SERVICO T2 ON T1.SERVICO_ID = T2.SERVICO_ID
        ORDER BY
            T1.DATA_SERVICO, T2.NOME
    )
    LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || rec.ID_HTL_SERVICO_QTDE || ' | Serviço: ' || rec.SERVICO || ' | Data: ' || rec.DATA || ' | Qtde: ' || rec.QTDE_SERVICO);
    END LOOP;        
END;
*/
/*
END HTL_SP_SERVICO_ATUALIZA_QTDE;
*/

/*
-- ==========================================
-- 3 - Implementar um Stored Procedure que receba o ID de um QUARTO e retorne 2 valores (parâmetros OUT) para o quarto informado: 
-- valor total de reservas (VALOR_CONTRATADO) com check out realizado e valor médio dos serviços realizados. 
-- ==========================================

CREATE OR REPLACE PROCEDURE HTL_SP_PROVA_CHECKOUT(
    P_QUARTO_ID               IN NUMBER,
    P_VALOR_CONTRATADO       OUT NUMBER,
    P_VALOR_MEDIO_SERVICO    OUT NUMBER
)
AS
BEGIN
    -- Inicializa os valores de saída como 0
    P_VALOR_CONTRATADO := 0;
    P_VALOR_MEDIO_SERVICO := 0;

    -- 1. Calcula o Valor Contratado
    SELECT SUM(VALOR_CONTRATADO)
    INTO P_VALOR_CONTRATADO
    FROM HTL_RESERVA
    WHERE QUARTO_ID = P_QUARTO_ID
    AND CHECK_OUT IS NOT NULL;

    -- 2. Calcula o Valor Médio dos Serviços
    SELECT AVG(res1.VALOR)
    INTO P_VALOR_MEDIO_SERVICO
    FROM HTL_RESERVA_SERVICO res1
    JOIN HTL_RESERVA res2 ON res1.RESERVA_ID = res2.RESERVA_ID
    WHERE res2.QUARTO_ID = P_QUARTO_ID
    AND res2.CHECK_OUT IS NOT NULL;

    -- O NVL nas consultas também é uma alternativa:
    -- SELECT NVL(SUM(VALOR_CONTRATADO), 0) INTO ...

    DBMS_OUTPUT.PUT_LINE('Valor total Reservas:' || P_VALOR_CONTRATADO);
    DBMS_OUTPUT.PUT_LINE('Valor média serviços:' || P_VALOR_MEDIO_SERVICO);
END;
*/

/*
-- ==========================================
-- 4 - Implementar uma Stored Function que receba o ID de uma RESERVA e retorne o valor total dos serviços executados
-- ==========================================

CREATE OR REPLACE FUNCTION HTL_SF_TOTAL_SERVICOS_RESERVA (
    p_reserva_id IN HTL_RESERVA.RESERVA_ID%TYPE
)
RETURN NUMBER
IS
    v_total NUMBER(10,2);
    v_reserva_existe INTEGER;
BEGIN
    -- 1. Verifica se a reserva existe (AGORA COM COUNT(*))
    SELECT COUNT(*) INTO v_reserva_existe
    FROM HTL_RESERVA
    WHERE RESERVA_ID = p_reserva_id;

    IF v_reserva_existe = 0 THEN
        RETURN 0; -- Reserva não existe
    END IF;

    -- 2. Calcula o total dos serviços associados à reserva
    SELECT NVL(SUM(VALOR), 0) INTO v_total
    FROM HTL_RESERVA_SERVICO
    WHERE RESERVA_ID = p_reserva_id;

    RETURN v_total;
*/

-- PARA O EXERCICIO 5
-- SE ESTE STORED FUNCTION estiver dando problema, vamos tirar o COUNT(*)
/*
CREATE OR REPLACE FUNCTION HTL_SF_TOTAL_SERVICOS_RESERVA (
    p_reserva_id IN HTL_RESERVA.RESERVA_ID%TYPE
)
RETURN NUMBER
IS
    v_total NUMBER(10,2);
    -- Removemos v_reserva_existe e a consulta à HTL_RESERVA
BEGIN
    -- 1. Calcula o total dos serviços associados à reserva
    -- O NVL(SUM(...), 0) garante que, se não houver serviços (tabela vazia), o valor é 0.
    SELECT NVL(SUM(VALOR), 0)
    INTO v_total
    FROM HTL_RESERVA_SERVICO
    WHERE RESERVA_ID = p_reserva_id;

    -- Se a RESERVA_ID não existir, a consulta acima retorna 0 (graças ao NVL), 
    -- o que é um comportamento aceitável para o UPDATE.

    RETURN v_total;

END HTL_SF_TOTAL_SERVICOS_RESERVA;
*/




/*
-- ==========================================
-- TUTORIAL DE USO: HTL_SF_TOTAL_SERVICOS_RESERVA
-- Objetivo: Demonstra como calcular o total de serviços para reservas específicas.
-- Baseado no DML fornecido: reservas de Bruno (ID=1), Fernanda (ID=2), etc.
-- ==========================================
SET SERVEROUTPUT ON;

-- EXEMPLO 1: Total de serviços para a reserva de Bruno (quarto '101', ID=1)
DECLARE
    v_total NUMBER(10,2);
BEGIN
    v_total := HTL_SF_TOTAL_SERVICOS_RESERVA(p_reserva_id => 1);
    DBMS_OUTPUT.PUT_LINE('Total de serviços para Reserva ID=1 (Bruno, quarto 101): ' || v_total);
END;

-- Resultado esperado: 100.00 (Café da manhã: 35.00, Lavanderia: 25.00, Serviço de Quarto: 40.00)

-- EXEMPLO 2: Total de serviços para a reserva de Fernanda (quarto '201', ID=2)
DECLARE
    v_total NUMBER(10,2);
BEGIN
    v_total := HTL_SF_TOTAL_SERVICOS_RESERVA(p_reserva_id => 2);
    DBMS_OUTPUT.PUT_LINE('Total de serviços para Reserva ID=2 (Fernanda, quarto 201): ' || v_total);
END;

-- Resultado esperado: 250.00 (Spa: 180.00, Jantar: 70.00)

-- EXEMPLO 3: Total de serviços para uma reserva sem serviços (Pedro, quarto '202', ID=3)
DECLARE
    v_total NUMBER(10,2);
BEGIN
    v_total := HTL_SF_TOTAL_SERVICOS_RESERVA(p_reserva_id => 3);
    DBMS_OUTPUT.PUT_LINE('Total de serviços para Reserva ID=3 (Pedro, quarto 202): ' || v_total);
END;

-- Resultado esperado: 0.00 (sem serviços associados)

-- EXEMPLO 4: Total de serviços para uma reserva inexistente
DECLARE
    v_total NUMBER(10,2);
BEGIN
    v_total := HTL_SF_TOTAL_SERVICOS_RESERVA(p_reserva_id => 999);
    DBMS_OUTPUT.PUT_LINE('Total de serviços para Reserva ID=999 (inexistente): ' || v_total);
END;

-- Resultado esperado: 0.00 (reserva não existe)

-- EXEMPLO 5: Relatório de serviços por reserva (todas as reservas)
DECLARE
    CURSOR c_reservas IS
        SELECT r.RESERVA_ID, h.NOME, q.IDENTIFICADOR
        FROM HTL_RESERVA r
        JOIN HTL_HOSPEDE h ON h.HOSPEDE_ID = r.HOSPEDE_ID
        JOIN HTL_QUARTO q ON q.QUARTO_ID = r.QUARTO_ID
        ORDER BY r.RESERVA_ID;
    v_total NUMBER(10,2);
BEGIN
    DBMS_OUTPUT.PUT_LINE('RELATÓRIO DE SERVIÇOS POR RESERVA');
    DBMS_OUTPUT.PUT_LINE('---------------------------------');
    DBMS_OUTPUT.PUT_LINE(RPAD('RESERVA_ID', 12) || RPAD('HÓSPEDE', 20) || 
                         RPAD('QUARTO', 10) || 'TOTAL SERVIÇOS');
    DBMS_OUTPUT.PUT_LINE('---------------------------------');
    FOR r_reserva IN c_reservas LOOP
        v_total := HTL_SF_TOTAL_SERVICOS_RESERVA(r_reserva.RESERVA_ID);
        DBMS_OUTPUT.PUT_LINE(
            RPAD(r_reserva.RESERVA_ID, 12) ||
            RPAD(r_reserva.NOME, 20) ||
            RPAD(r_reserva.IDENTIFICADOR, 10) ||
            TO_CHAR(v_total, 'FM9999990.00')
        );
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('---------------------------------');
END;
*/
/*
END HTL_SF_TOTAL_SERVICOS_RESERVA;
*/


/*
-- --------------------------------------------------------------------------------
-- 5 - Criar campo VALOR_SERVICOS (NUMBER(5,0)) na tabela HTL_RESERVA e utilizar a 
-- função da questão 4 para atualizá-la para todos as reservas.
-- --------------------------------------------------------------------------------


-- 5.1 ALTERAR TABELA: Adicionar a coluna VALOR_SERVICOS
-- --------------------------------------------------------------------------------
ALTER TABLE HTL_RESERVA
    ADD VALOR_SERVICOS NUMBER(5,0);


-- --------------------------------------------------------------------------------
-- 5.2 ATUALIZAR DADOS: Preencher o novo campo com o resultado da Function
-- --------------------------------------------------------------------------------
UPDATE HTL_RESERVA T1
    SET T1.VALOR_SERVICOS = HTL_SF_TOTAL_SERVICOS_RESERVA(T1.RESERVA_ID);

-- Confirma a transação
COMMIT;

-- ==========================================
-- TUTORIAL E TESTE: VERIFICAÇÃO FINAL
-- ==========================================

-- Verificação dos valores atualizados
SELECT
    R.RESERVA_ID,
    H.NOME AS HOSPEDE,
    R.VALOR_CONTRATADO AS DIARIAS,
    R.VALOR_SERVICOS AS SERVICOS_CALCULADO,
    (R.VALOR_CONTRATADO + R.VALOR_SERVICOS) AS VALOR_TOTAL_FINAL
FROM
    HTL_RESERVA R
JOIN
    HTL_HOSPEDE H ON R.HOSPEDE_ID = H.HOSPEDE_ID
ORDER BY
    R.RESERVA_ID;

*/
END A_PERDA_DE_TEMPO_01;