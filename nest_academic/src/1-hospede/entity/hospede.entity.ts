import { BaseEntity, Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

/**
 * Entidade que representa a tabela COCAO_HOSPEDE no banco de dados.
 * Superclasse para hóspedes e funcionários (generalização).
 * 
 * - ID_USUARIO: Gerado automaticamente pelo banco (IDENTITY).
 * - TIPO: 0 = Hóspede comum, 1 = Funcionário.
 * - ATIVO: 1 = Ativo, 0 = Inativo.
 * - Herda de BaseEntity para CREATED_AT e UPDATED_AT automáticos.
 * 
 * Observações:
 * - Campos opcionais (nullable: true): RG, EMAIL, TELEFONE.
 * - Validações (CHECK constraints) gerenciadas no banco.
 * - Tipos compatíveis com Oracle: varchar2, char, number, date.
 */

/* 
 * Diferenças em relação ao modelo antigo ('Cidade'):
 * 
 * 1. PrimaryGeneratedColumn: 'increment' (antigo, genérico para bancos como PostgreSQL/MySQL) vs. 'identity' (nativo do Oracle 12c+ para GENERATED BY DEFAULT AS IDENTITY). Me foi sugerido para o TypeORM para Oracle, diz que é mais eficiente, evita sequências extras e conflitos.
 * 
 * 2. Inicialização da PK (idCidade?: number = 0;): Removida, pois o Oracle gerencia via IDENTITY; TypeORM preenche pós-insert. Torna o código mais limpo, sem defaults desnecessários.
 * 
 * 3. Inicializações de strings (''): Aplicadas seletivamente em campos obrigatórios (ex.: nomeHospede = '') para defaults vazios em memória (útil em formulários/testes). Opcionais ficam sem, permitindo undefined/null, alinhado ao DDL (NULL permitido).
 * 
 * 4. Nullable: Omitido no antigo (TypeORM infere default como false para obrigatórios). Adicionado para mostrar NOT NULL diretamente no código.
 */

@Entity('COCAO_HOSPEDE')
export class Hospede extends BaseEntity {
  @PrimaryGeneratedColumn('identity', {
    name: 'ID_USUARIO',
    type: 'number',
  })
  // Chave primária gerada automaticamente pelo Oracle (GENERATED BY DEFAULT AS IDENTITY).
  // O banco gerencia o incremento.
  idUsuario?: number;

  @Column({
    name: 'NOME_HOSPEDE',
    type: 'varchar2',
    length: 100,
    nullable: false,
  })
  // Nome completo do hóspede ou funcionário (obrigatório).
  nomeHospede: string = '';

  @Column({
    name: 'CPF',
    type: 'char',
    length: 11,
    nullable: false,
  })
  // CPF único (validação regex no banco: apenas dígitos, 11 chars).
  cpf: string = '';

  @Column({
    name: 'RG',
    type: 'varchar2',
    length: 20,
    nullable: true,
  })
  // RG opcional (validação regex no banco: 7-9 chars alfanuméricos).
  rg?: string;

  @Column({
    name: 'SEXO',
    type: 'char',
    length: 1,
    nullable: false,
  })
  // Sexo: 'M', 'F' ou 'O' (check no banco).
  sexo: string = '';

  @Column({
    name: 'DATA_NASCIMENTO',
    type: 'date',
    nullable: false,
  })
  // Data de nascimento (obrigatória, formato DATE no Oracle).
  dataNascimento: Date = new Date();

  @Column({
    name: 'EMAIL',
    type: 'varchar2',
    length: 100,
    nullable: true,
  })
  // Email opcional (validação regex no banco se fornecido).
  email?: string;

  @Column({
    name: 'TELEFONE',
    type: 'varchar2',
    length: 20,
    nullable: true,
  })
  // Telefone opcional (validação regex no banco se fornecido).
  telefone?: string;

  @Column({
    name: 'TIPO',
    type: 'number',
    nullable: false,
    default: 0,
  })
  // Tipo de usuário: 0 = Hóspede, 1 = Funcionário (check no banco).
  tipo: number = 0;

  @Column({
    name: 'ATIVO',
    type: 'number',
    nullable: false,
    default: 1,
  })
  // Status ativo: 1 = Ativo, 0 = Inativo (check no banco).
  ativo: number = 1;

  // Construtor opcional com Partial<Hospede>.
  // Útil para inicializar objetos parciais em testes ou DTOs.
  // Exemplo: new Hospede({ nomeHospede: 'João Silva', cpf: '12345678901' });
  constructor(data: Partial<Hospede> = {}) {
    super();
    Object.assign(this, data);
  }
}

/**
 * ==============================================================
 * TUTORIAL RÁPIDO: hospede.entity.ts
 * ==============================================================
 * 
 * O que é?
 *   - Define a estrutura da tabela COCAO_HOSPEDE no TypeORM.
 *   - Mapeia colunas do DDL para propriedades TypeScript.
 * 
 * Para que serve?
 *   - Usado pelo repositório para CRUD no banco.
 *   - Herda BaseEntity para timestamps automáticos.
 *   - Integra com Oracle: IDENTITY para PK, tipos varchar2/char/number/date.
 * 
 * Dicas:
 *   - Não inclui lógica de negócios aqui (isso fica no service).
 *   - Constraints/validações são no DDL; aqui só mapeamos.
 *   - Importe em hospede.module.ts e service para uso.
 * 
 * ==============================================================
 */